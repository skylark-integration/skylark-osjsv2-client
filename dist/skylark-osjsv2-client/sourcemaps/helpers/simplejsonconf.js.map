{"version":3,"sources":["helpers/simplejsonconf.js"],"names":["define","isObject","item","Array","isArray","exports","from","obj","getJSON","path","defaultValue","setJSON","value","opts","json","result","ns","split","forEach","k","i","queue","length","isTree","options","Object","assign","prune","guess","JSON","parse","e","String","guessValue","mergeDeep","target","source","key","[object Object]","resulted","getNewTree","removeNulls","splice"],"mappings":";;;;;;;AAAAA,UAAU,WAUR,aAKA,SAASC,EAASC,GAChB,OAAQA,GAAwB,iBAATA,IAAsBC,MAAMC,QAAQF,IAAkB,OAATA,EA2BtE,IAAIG,SAWJC,KAAgBC,KAEZC,QAAS,CAACC,EAAMC,IACPL,QAAQG,QAAQD,EAAKE,EAAMC,GAEpCC,QAAS,CAACF,EAAMG,EAAOC,IACdR,QAAQM,QAAQJ,EAAKE,EAAMG,EAAOC,KAiB/CL,QAAkB,CAACM,EAAML,EAAMC,KAC7B,GAAqB,iBAATD,EAAoB,CAC9B,IAAIM,EAAS,KACTC,EAAKF,EAUT,OARAL,EAAKQ,MAAM,MAAMC,QAAQ,CAACC,EAAGC,EAAGC,KACzBD,GAAKC,EAAMC,OAAS,EACvBP,EAASC,EAAGG,GAEZH,EAAKA,EAAGG,UAIa,IAAXJ,EAAyBL,EAAeK,EAGxD,OAAOD,IAwFX,OApEET,QAAQM,QAAU,MA6ChB,OAAO,SAASG,EAAML,EAAMG,EAAOC,GACjC,MAAMU,GAAUd,EACVe,EAAUC,OAAOC,QACrBC,OAAO,EACPC,OAAO,EACPhB,MAAO,MACNC,QAEGU,GAAUC,EAAQI,QACtBhB,EAhBJ,SAAoBA,GAClB,IACE,OAAOiB,KAAKC,MAAMlB,GAClB,MAAQmB,IACV,OAAOC,OAAOpB,GAYJqB,CAAWrB,IAGrB,IACIG,EArJR,SAASmB,EAAUC,EAAQC,GACzB,GAAKnC,EAASkC,IAAWlC,EAASmC,GAChC,IAAM,IAAIC,KAAOD,EACVnC,EAASmC,EAAOC,KACbF,EAAOE,WAAeF,EAAOE,WAAgBD,EAAOC,IACxDZ,OAAOC,OAAOS,GACZG,CAACD,QAGLH,EAAUC,EAAOE,GAAMD,EAAOC,KAE9BZ,OAAOC,OAAOS,GACZG,CAACD,GAAMD,EAAOC,KAMtB,OAAOF,EAmIQD,CAAUpB,EADTS,EAASX,EAvCzB,SAAoByB,EAAKzB,GACvB,MAAMS,EAAQgB,EAAIpB,MAAM,MAExB,IAAIsB,KACAvB,EAAKuB,EAaT,OAXAlB,EAAMH,QAAQ,CAACC,EAAGC,KACXA,GAAKC,EAAMC,OAAS,EACvBN,EAAGG,GAAKP,QAEc,IAAVI,EAAGG,KACbH,EAAGG,OAELH,EAAKA,EAAGG,MAILoB,EAsBwBC,CAAW/B,EAAMG,IAOhD,OAJKY,EAAQG,OA1Df,SAASc,EAAYlC,GACnB,MAAMH,EAAUG,aAAeJ,MAE/B,IAAM,IAAIgB,KAAKZ,EACG,OAAXA,EAAIY,GACFf,EACHG,EAAImC,OAAOvB,EAAG,UAEPZ,EAAIY,GAEe,iBAAXZ,EAAIY,IACrBsB,EAAYlC,EAAIY,IAgDlBsB,CAAY1B,GAGPA,IAhEO,GAoEbV","file":"../../helpers/simplejsonconf.js","sourcesContent":["define([],function(){\r\n  /*!\r\n   * Module: simplejsonconf\r\n   *\r\n   * Use JSON as a configuration file\r\n   *\r\n   * @author Anders Evenrud <andersevenrud@gmail.com>\r\n   * @license MIT\r\n   */\r\n\r\n  'use strict';\r\n\r\n  /*\r\n   * Check if this is an \"Object\"\r\n   */\r\n  function isObject(item) {\r\n    return (item && typeof item === 'object' && !Array.isArray(item) && item !== null);\r\n  }\r\n\r\n  /*\r\n   * Merges the two objects together\r\n   */\r\n  function mergeDeep(target, source) {\r\n    if ( isObject(target) && isObject(source) ) {\r\n      for ( var key in source ) {\r\n        if ( isObject(source[key]) ) {\r\n          if ( !target[key] || typeof target[key] !== typeof source[key] ) {\r\n            Object.assign(target, {\r\n              [key]: {}\r\n            });\r\n          }\r\n          mergeDeep(target[key], source[key]);\r\n        } else {\r\n          Object.assign(target, {\r\n            [key]: source[key]\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  var exports = {};\r\n\r\n  /**\r\n   * Creates a new proxy object with getJSON/setJSON methods for given JSON object.\r\n   *\r\n   * @param {Object}  obj       The JSON object\r\n   *\r\n   * @memberof simplejsonconf\r\n   * @function from\r\n   * @return {Object} A proxy object\r\n   */\r\n  exports.from = (obj) => {\r\n    return {\r\n      getJSON: (path, defaultValue) => {\r\n        return exports.getJSON(obj, path, defaultValue);\r\n      },\r\n      setJSON: (path, value, opts) => {\r\n        return exports.setJSON(obj, path, value, opts);\r\n      }\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Resolves the given path in JSON object and returns value\r\n   *\r\n   * @example .getJSON({foo: {bar: 'baz'}}, 'foo.bar') => 'baz'\r\n   *\r\n   * @param {Object}  json          The JSON object\r\n   * @param {String}  [path=null]   The path to seek. If empty, the entire tree is returned\r\n   *\r\n   * @memberof simplejsonconf\r\n   * @function getJSON\r\n   * @return {Mixed} Result for the path\r\n   */\r\n  exports.getJSON = (json, path, defaultValue) => {\r\n    if ( typeof path === 'string' ) {\r\n      let result = null;\r\n      let ns = json;\r\n\r\n      path.split(/\\./).forEach((k, i, queue) => {\r\n        if ( i >= queue.length - 1 ) {\r\n          result = ns[k];\r\n        } else {\r\n          ns = ns[k];\r\n        }\r\n      });\r\n\r\n      return typeof result === 'undefined' ? defaultValue : result;\r\n    }\r\n\r\n    return json;\r\n  };\r\n\r\n\r\n  /**\r\n   * Resolves the given path in JSON object and returns value\r\n   *\r\n   * @example .setJSON({foo: {bar: 'baz'}}, 'foo.bar', 'jazz') => {foo: {bar: 'jazz'}}\r\n   *\r\n   * @param {Object}          json                      The JSON object\r\n   * @param {String}          path                      The path to seek. If you set this as 'null' you can define the value as a tree\r\n   * @param {Mixed}           value                     The value to set on the path\r\n   * @param {Object}          [options]                 A set of options\r\n   * @param {Boolean}         [options.prune=false]     Remove 'null' from the tree (this also prunes empty objects)\r\n   * @param {Boolean}         [options.guess=false]     Try to guess what kind of type this value is\r\n   *\r\n   * @memberof simplejsonconf\r\n   * @function setJSON\r\n   * @return {Object} The new JSON object\r\n   */\r\n  exports.setJSON = (() => {\r\n\r\n    function removeNulls(obj) {\r\n      const isArray = obj instanceof Array;\r\n\r\n      for ( let k in obj ) {\r\n        if ( obj[k] === null ) {\r\n          if ( isArray ) {\r\n            obj.splice(k, 1);\r\n          } else {\r\n            delete obj[k];\r\n          }\r\n        } else if ( typeof obj[k] === 'object') {\r\n          removeNulls(obj[k]);\r\n        }\r\n      }\r\n    }\r\n\r\n    function getNewTree(key, value) {\r\n      const queue = key.split(/\\./);\r\n\r\n      let resulted = {};\r\n      let ns = resulted;\r\n\r\n      queue.forEach((k, i) => {\r\n        if ( i >= queue.length - 1 ) {\r\n          ns[k] = value;\r\n        } else {\r\n          if ( typeof ns[k] === 'undefined' ) {\r\n            ns[k] = {};\r\n          }\r\n          ns = ns[k];\r\n        }\r\n      });\r\n\r\n      return resulted;\r\n    }\r\n\r\n    function guessValue(value) {\r\n      try {\r\n        return JSON.parse(value);\r\n      } catch ( e ) {}\r\n      return String(value);\r\n    }\r\n\r\n    return function(json, path, value, opts) {\r\n      const isTree = !path;\r\n      const options = Object.assign({\r\n        prune: false,\r\n        guess: false,\r\n        value: null,\r\n      }, opts || {});\r\n\r\n      if ( !isTree && options.guess ) {\r\n        value = guessValue(value);\r\n      }\r\n\r\n      let newTree = isTree ? value : getNewTree(path, value);\r\n      let result = mergeDeep(json, newTree);\r\n\r\n      if ( options.prune ) {\r\n        removeNulls(result);\r\n      }\r\n\r\n      return result;\r\n    };\r\n  })();\r\n\r\nreturn exports;\r\n\r\n});"]}