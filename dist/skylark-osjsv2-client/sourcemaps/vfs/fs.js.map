{"version":3,"sources":["vfs/fs.js"],"names":["define","FS","FileMetadata","FileDataURL","Process","MountManager","PackageManager","SettingsManager","Connection","a","watches","noop","err","res","console","error","warn","hasAlias","item","retm","module","getModuleFromPath","path","match","option","options","alias","replace","checkMetadataArgument","checkRo","TypeError","_","mountpoint","Error","isReadOnly","name","hasSameTransport","src","dest","msrc","mdst","existsWrapper","overwrite","Promise","resolve","reject","exists","then","result","catch","requestWrapper","method","args","appRef","info","arguments","request","response","instance","onVFSRequestCompleted","performRequest","test","errorStr","Object","broadcastMessage","msg","_message","i","message","source","__pid","obj","forEach","w","checkPath","_check","f","type","substr","length","wasTouched","destination","cb","checkWatches","aliased","_transform","n","found","getModules","iter","findAlias","tuple","move","e","dialogProgress","prog","dialog","setProgress","promise","sourceMountpoint","destMountpoint","data","find","scandir","vfsSettings","get","oitem","Array","filterScandir","map","isShortcut","shortcut","niter","str","tmp","pathJoin","backlink","back","isOnRoot","split","root","some","filename","dirname","mime","size","createBackLink","unshift","write","convertTo","m","d","toString","window","Blob","convertWriteData","ab","read","types","datasource","yes","no","abToDataSource","dataSource","text","abToText","blob","abToBlob","json","jsn","JSON","parse","stack","toLowerCase","copy","assign","arrayBuffer","rename","unlink","chkdir","generateUserMetadata","mkdir","fileinfo","url","upload","files","all","File","fileDest","download","file","trash","untrash","emptyTrash","freeSpace","watch","callback","push","unwatch","idx","triggerWatch","arg"],"mappings":"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","file":"../../vfs/fs.js","sourcesContent":["define([\n    '../utils/fs',\n    './file',\n    './filedataurl',\n    '../core/process',\n    '../core/mount-manager',\n    '../core/package-manager',\n    '../core/settings-manager',\n    '../core/connection',\n    '../core/locales'\n], function (FS, FileMetadata, FileDataURL, Process, MountManager, PackageManager, SettingsManager, Connection, a) {\n    'use strict';\n    let watches = [];\n    function noop(err, res) {\n        if (err) {\n            console.error('VFS operation without callback caused an error', err);\n        } else {\n            console.warn('VFS operation without callback', res);\n        }\n    }\n    function hasAlias(item, retm) {\n        const module = MountManager.getModuleFromPath(item.path);\n        if (module) {\n            const match = module.option('match');\n            const options = module.option('options');\n            if (options && options.alias) {\n                return retm ? module : item.path.replace(match, options.alias);\n            }\n        }\n        return false;\n    }\n    function checkMetadataArgument(item, err, checkRo) {\n        if (typeof item === 'string') {\n            item = new FileMetadata(item);\n        } else if (typeof item === 'object' && item.path) {\n            item = new FileMetadata(item);\n        }\n        if (!(item instanceof FileMetadata)) {\n            throw new TypeError(err || a._('ERR_VFS_EXPECT_FILE'));\n        }\n        const alias = hasAlias(item);\n        if (alias) {\n            item.path = alias;\n        }\n        const mountpoint = MountManager.getModuleFromPath(item.path);\n        if (!mountpoint) {\n            throw new Error(a._('ERR_VFSMODULE_NOT_FOUND_FMT', item.path));\n        }\n        if (checkRo && mountpoint.isReadOnly()) {\n            throw new Error(a._('ERR_VFSMODULE_READONLY_FMT', mountpoint.name));\n        }\n        return item;\n    }\n    function hasSameTransport(src, dest) {\n        const msrc = MountManager.getModuleFromPath(src.path);\n        const mdst = MountManager.getModuleFromPath(dest.path);\n        if (!msrc || !mdst || msrc === mdst) {\n            return true;\n        }\n        if (msrc && mdst && (msrc.option('internal') && mdst.option('internal'))) {\n            return true;\n        }\n        return msrc.option('transport') === mdst.option('tranport');\n    }\n    function existsWrapper(item, options) {\n        options = options || {};\n        if (options.overwrite) {\n            return Promise.resolve();\n        }\n        return new Promise((resolve, reject) => {\n            exists(item).then(result => {\n                if (result) {\n                    return reject(new Error(a._('ERR_VFS_FILE_EXISTS')));\n                }\n                return resolve();\n            }).catch(error => {\n                if (error) {\n                    console.warn('existsWrapper() error', error);\n                }\n                reject(error);\n            });\n        });\n    }\n    function createBackLink(item, result, alias, oitem) {\n        const path = item.path.split('://')[1].replace(/\\/+/g, '/').replace(/^\\/?/, '/');\n        let isOnRoot = path === '/';\n        if (alias) {\n            isOnRoot = oitem.path === alias.root;\n        }\n        if (!isOnRoot) {\n            const foundBack = result.some(function (iter) {\n                return iter.filename === '..';\n            });\n            if (!foundBack) {\n                return new FileMetadata({\n                    filename: '..',\n                    path: FS.dirname(item.path),\n                    mime: null,\n                    size: 0,\n                    type: 'dir'\n                });\n            }\n        }\n        return false;\n    }\n    function checkWatches(msg, obj) {\n        watches.forEach(function (w) {\n            const checkPath = w.path;\n            function _check(f) {\n                if (w.type === 'dir') {\n                    return f.path.substr(0, checkPath.length) === checkPath;\n                }\n                return f.path === checkPath;\n            }\n            let wasTouched = false;\n            if (obj.destination) {\n                wasTouched = _check(obj.destination);\n                if (!wasTouched) {\n                    wasTouched = _check(obj.source);\n                }\n            } else {\n                wasTouched = _check(obj);\n            }\n            if (wasTouched) {\n                w.cb(msg, obj);\n            }\n        });\n    }\n    function findAlias(item) {\n        const mm = MountManager;\n        let found = null;\n        mm.getModules().forEach(function (iter) {\n            if (!found && iter.option('options').alias) {\n                const a = iter.option('options').alias;\n                if (item.path.substr(0, a.length) === a) {\n                    found = iter;\n                }\n            }\n        });\n        return found;\n    }\n    function convertWriteData(data, mime) {\n        const convertTo = (m, d, resolve, reject) => {\n            FS[m](d, mime, function (error, response) {\n                if (error) {\n                    reject(new Error(error));\n                } else {\n                    resolve(response);\n                }\n            });\n        };\n        return new Promise((resolve, reject) => {\n            try {\n                if (typeof data === 'string') {\n                    if (data.length) {\n                        return convertTo('textToAb', data, resolve, reject);\n                    }\n                } else {\n                    if (data instanceof FileDataURL) {\n                        return convertTo('dataSourceToAb', data.toString(), resolve, reject);\n                    } else if (window.Blob && data instanceof window.Blob) {\n                        return convertTo('blobToAb', data, resolve, reject);\n                    }\n                }\n            } catch (e) {\n                return reject(e);\n            }\n            return resolve(data);\n        });\n    }\n    function requestWrapper(mountpoint, method, args, options, appRef) {\n        console.info('VFS operation', ...arguments);\n        if (!mountpoint) {\n            return Promise.reject(new Error(a._('ERR_VFSMODULE_INVALID')));\n        }\n        return new Promise((resolve, reject) => {\n            mountpoint.request(method, args, options).then(response => {\n                return Connection.instance.onVFSRequestCompleted(mountpoint, method, args, response, appRef).then(() => resolve(response)).catch(reject);\n            }).catch(reject);\n        });\n    }\n    function performRequest(method, args, options, test, appRef, errorStr) {\n        return new Promise((resolve, reject) => {\n            if (options && !(options instanceof Object)) {\n                reject(new TypeError(a._('ERR_ARGUMENT_FMT', 'VFS::' + method, 'options', 'Object', typeof options)));\n                return;\n            }\n            const mountpoint = MountManager.getModuleFromPath(test);\n            if (!mountpoint) {\n                reject(new Error(a._('ERR_VFSMODULE_NOT_FOUND_FMT', test)));\n                return;\n            }\n            requestWrapper(mountpoint, method, args, options, appRef).then(resolve).catch(reject);\n        });\n    }\n    function broadcastMessage(msg, item, appRef) {\n        function _message(i) {\n            Process.message(msg, i, { source: appRef ? appRef.__pid : null });\n            checkWatches(msg, item);\n        }\n        const aliased = function () {\n            function _transform(i) {\n                if (i instanceof FileMetadata) {\n                    const n = new FileMetadata(i);\n                    const alias = findAlias(n);\n                    if (alias) {\n                        n.path = n.path.replace(alias.option('options').alias, alias.option('root'));\n                        return n;\n                    }\n                }\n                return false;\n            }\n            if (item instanceof FileMetadata) {\n                return _transform(item);\n            } else if (item && item.destination && item.source) {\n                return {\n                    source: _transform(item.source),\n                    destination: _transform(item.destination)\n                };\n            }\n            return null;\n        }();\n        _message(item);\n        const tuple = aliased.source || aliased.destination;\n        if (aliased && (aliased instanceof FileMetadata || tuple)) {\n            if (tuple) {\n                aliased.source = aliased.source || item.source;\n                aliased.destination = aliased.destination || item.destination;\n            }\n            _message(aliased);\n        }\n    }\n    function find(item, args, options) {\n        options = options || {};\n        if (arguments.length < 2) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('find', [\n            item,\n            args\n        ], options, item.path, null, 'ERR_VFSMODULE_FIND_FMT');\n    }\n    function scandir(item, options) {\n        const vfsSettings = SettingsManager.get('VFS');\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        const oitem = new FileMetadata(item);\n        const alias = hasAlias(oitem, true);\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return new Promise((resolve, reject) => {\n            performRequest('scandir', [item], options, item.path, null, 'ERR_VFSMODULE_SCANDIR_FMT').then(result => {\n                if (result instanceof Array) {\n                    result = FS.filterScandir(result, options, vfsSettings);\n                    if (alias) {\n                        result = result.map(function (iter) {\n                            const isShortcut = iter.shortcut === true;\n                            const niter = new FileMetadata(iter);\n                            if (!isShortcut) {\n                                const str = iter.path.replace(/\\/?$/, '');\n                                const opt = alias.option('options') || {};\n                                const tmp = opt.alias.replace(/\\/?$/, '');\n                                niter.path = FS.pathJoin(alias.option('root'), str.replace(tmp, ''));\n                            }\n                            return niter;\n                        });\n                    }\n                    if (options.backlink !== false) {\n                        const back = createBackLink(item, result, alias, oitem);\n                        if (back) {\n                            result.unshift(back);\n                        }\n                    }\n                }\n                return resolve(result);\n            }).catch(reject);\n        });\n    }\n    function write(item, data, options, appRef) {\n        options = options || {};\n        if (arguments.length < 2) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item, null, true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return new Promise((resolve, reject) => {\n            const mountpoint = MountManager.getModuleFromPath(item.path);\n            convertWriteData(data, item.mime).then(ab => {\n                requestWrapper(mountpoint, 'write', [\n                    item,\n                    ab\n                ], options, appRef).then(resolve).catch(e => {\n                    reject(new Error(a._('ERR_VFSMODULE_WRITE_FMT', e)));\n                });\n                return true;\n            }).catch(e => {\n                reject(new Error(a._('ERR_VFSMODULE_WRITE_FMT', e)));\n            });\n        });\n    }\n    function read(item, options) {\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return new Promise((resolve, reject) => {\n            const mountpoint = MountManager.getModuleFromPath(item.path);\n            requestWrapper(mountpoint, 'read', [item], options).then(response => {\n                if (options.type) {\n                    const types = {\n                        datasource: () => new Promise((yes, no) => {\n                            FS.abToDataSource(response, item.mime, function (error, dataSource) {\n                                return error ? no(error) : yes(dataSource);\n                            });\n                        }),\n                        text: () => new Promise((yes, no) => {\n                            FS.abToText(response, item.mime, function (error, text) {\n                                return error ? no(error) : yes(text);\n                            });\n                        }),\n                        blob: () => new Promise((yes, no) => {\n                            FS.abToBlob(response, item.mime, function (error, blob) {\n                                return error ? no(error) : yes(blob);\n                            });\n                        }),\n                        json: () => new Promise((yes, no) => {\n                            FS.abToText(response, item.mime, function (error, text) {\n                                let jsn;\n                                if (typeof text === 'string') {\n                                    try {\n                                        jsn = JSON.parse(text);\n                                    } catch (e) {\n                                        console.warn('VFS::read()', 'readToJSON', e.stack, e);\n                                    }\n                                }\n                                return error ? no(error) : yes(jsn);\n                            });\n                        })\n                    };\n                    const type = options.type.toLowerCase();\n                    if (types[type]) {\n                        return types[type]().then(resolve).catch(reject);\n                    }\n                }\n                return resolve(response);\n            }).catch(e => {\n                reject(new Error(a._('ERR_VFSMODULE_READ_FMT', e)));\n            });\n        });\n    }\n    function copy(src, dest, options, appRef) {\n        options = options || {};\n        if (arguments.length < 2) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            src = checkMetadataArgument(src, a._('ERR_VFS_EXPECT_SRC_FILE'));\n            dest = checkMetadataArgument(dest, a._('ERR_VFS_EXPECT_DST_FILE'), true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        options = Object.assign({}, {\n            type: 'binary',\n            dialog: null\n        }, options);\n        options.arrayBuffer = true;\n        function dialogProgress(prog) {\n            if (options.dialog) {\n                options.dialog.setProgress(prog);\n            }\n        }\n        const promise = new Promise((resolve, reject) => {\n            existsWrapper(dest, options).then(() => {\n                const sourceMountpoint = MountManager.getModuleFromPath(src.path);\n                const destMountpoint = MountManager.getModuleFromPath(dest.path);\n                if (hasSameTransport(src, dest)) {\n                    requestWrapper(sourceMountpoint, 'copy', [\n                        src,\n                        dest\n                    ], options, appRef).then(() => {\n                        dialogProgress(100);\n                        return resolve(true);\n                    }).catch(reject);\n                } else {\n                    requestWrapper(sourceMountpoint, 'read', [src], options, appRef).then(data => {\n                        dialogProgress(50);\n                        return requestWrapper(destMountpoint, 'write', [\n                            dest,\n                            data\n                        ], options, appRef).then(res => {\n                            dialogProgress(100);\n                            return resolve(res);\n                        }).catch(reject);\n                    }).catch(reject);\n                }\n                return true;\n            }).catch(reject);\n        });\n        return new Promise((resolve, reject) => {\n            promise.then(resolve).catch(e => {\n                dialogProgress(100);\n                reject(new Error(a._('ERR_VFSMODULE_COPY_FMT', e)));\n            });\n        });\n    }\n    function move(src, dest, options, appRef) {\n        options = options || {};\n        if (arguments.length < 2) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            src = checkMetadataArgument(src, a._('ERR_VFS_EXPECT_SRC_FILE'));\n            dest = checkMetadataArgument(dest, a._('ERR_VFS_EXPECT_DST_FILE'), true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        function dialogProgress(prog) {\n            if (options.dialog) {\n                options.dialog.setProgress(prog);\n            }\n        }\n        const promise = new Promise((resolve, reject) => {\n            existsWrapper(dest, options).then(() => {\n                const sourceMountpoint = MountManager.getModuleFromPath(src.path);\n                const destMountpoint = MountManager.getModuleFromPath(dest.path);\n                if (hasSameTransport(src, dest)) {\n                    requestWrapper(sourceMountpoint, 'move', [\n                        src,\n                        dest\n                    ], options, appRef).then(() => {\n                        dialogProgress(100);\n                        return resolve(true);\n                    }).catch(reject);\n                } else {\n                    requestWrapper(sourceMountpoint, 'read', [src], options, appRef).then(data => {\n                        dialogProgress(50);\n                        return requestWrapper(destMountpoint, 'write', [\n                            dest,\n                            data\n                        ], options, appRef).then(res => {\n                            return requestWrapper(sourceMountpoint, 'unlink', [src], options, appRef).then(res => {\n                                dialogProgress(100);\n                                return resolve(res);\n                            }).catch(reject);\n                        }).catch(reject);\n                    }).catch(reject);\n                }\n                return true;\n            }).catch(reject);\n        });\n        return new Promise((resolve, reject) => {\n            promise.then(resolve).catch(e => {\n                dialogProgress(100);\n                reject(new Error(a._('ERR_VFSMODULE_MOVE_FMT', e)));\n            });\n        });\n    }\n    function rename(src, dest) {\n        return move(...arguments);\n    }\n    function unlink(item, options, appRef) {\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item, null, true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return new Promise((resolve, reject) => {\n            performRequest('unlink', [item], options, item.path, appRef, 'ERR_VFSMODULE_UNLINK_FMT').then(response => {\n                const pkgdir = SettingsManager.instance('PackageManager').get('PackagePaths', []);\n                const found = pkgdir.some(function (i) {\n                    const chkdir = new FileMetadata(i);\n                    const idir = FS.dirname(item.path);\n                    return idir === chkdir.path;\n                });\n                if (found) {\n                    PackageManager.generateUserMetadata(function () {\n                    });\n                }\n                return resolve(response);\n            }).catch(reject);\n        });\n    }\n    function mkdir(item, options, appRef) {\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item, null, true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('mkdir', [item], options, item.path, appRef, 'ERR_VFSMODULE_MKDIR_FMT');\n    }\n    function exists(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('exists', [item], {}, item.path, null, 'ERR_VFSMODULE_EXISTS_FMT');\n    }\n    function fileinfo(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('fileinfo', [item], {}, item.path, null, 'ERR_VFSMODULE_FILEINFO_FMT');\n    }\n    function url(item, options) {\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('url', [item], options, item.path, null, 'ERR_VFSMODULE_URL_FMT');\n    }\n    function upload(args, options, appRef) {\n        args = args || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        if (!args.files) {\n            return Promise.reject(new Error(a._('ERR_VFS_UPLOAD_NO_FILES')));\n        }\n        if (!args.destination) {\n            return Promise.reject(new Error(a._('ERR_VFS_UPLOAD_NO_DEST')));\n        }\n        const dest = new FileMetadata(args.destination);\n        const mountpoint = MountManager.getModuleFromPath(args.destination);\n        return new Promise((resolve, reject) => {\n            Promise.all(args.files.map(f => {\n                const filename = f instanceof window.File ? f.name : f.filename;\n                const fileDest = new FileMetadata(FS.pathJoin(args.destination, filename));\n                return new Promise((resolve, reject) => {\n                    existsWrapper(fileDest, options).then(() => {\n                        return requestWrapper(mountpoint, 'upload', [\n                            dest,\n                            f\n                        ], options, appRef).then(resolve).catch(reject);\n                    }).catch(reject);\n                });\n            })).then(resolve).catch(e => {\n                reject(new Error(a._('ERR_VFS_UPLOAD_FAIL_FMT', e)));\n            });\n        });\n    }\n    function download(file) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            file = checkMetadataArgument(file);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        if (!file.path) {\n            return Promise.reject(new Error(a._('ERR_VFS_DOWNLOAD_NO_FILE')));\n        }\n        const promise = new Promise((resolve, reject) => {\n            const mountpoint = MountManager.getModuleFromPath(file);\n            requestWrapper(mountpoint, 'download', [file], {}).then(() => {\n                if (mountpoint.option('internal')) {\n                    mountpoint.download(file).then(resolve).catch(reject);\n                } else {\n                    mountpoint.read(file).then(resolve).catch(reject);\n                }\n                return true;\n            });\n        });\n        return new Promise((resolve, reject) => {\n            promise.then(resolve).catch(e => {\n                reject(new Error(a._('ERR_VFS_DOWNLOAD_FAILED', e)));\n            });\n        });\n    }\n    function trash(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('trash', [item], {}, item.path, null, 'ERR_VFSMODULE_TRASH_FMT');\n    }\n    function untrash(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('untrash', [item], {}, item.path, null, 'ERR_VFSMODULE_UNTRASH_FMT');\n    }\n    function emptyTrash() {\n        return performRequest('emptyTrash', [], {}, null, null, 'ERR_VFSMODULE_EMPTYTRASH_FMT');\n    }\n    function freeSpace(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(a._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        const m = MountManager.getModuleFromPath(item.path, false, true);\n        return performRequest('freeSpace', [m.option('root')], {}, item.path, null, 'ERR_VFSMODULE_FREESPACE_FMT');\n    }\n    function watch(item, callback) {\n        callback = callback || noop;\n        if (arguments.length < 2) {\n            callback(a._('ERR_VFS_NUM_ARGS'));\n            return -1;\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return Promise.resolve(watches.push({\n            path: item.path,\n            type: item.type,\n            cb: callback\n        }) - 1);\n    }\n    function unwatch(idx) {\n        if (typeof watches[idx] !== 'undefined') {\n            delete watches[idx];\n        }\n    }\n    function triggerWatch(method, arg, appRef) {\n        broadcastMessage('vfs:' + method, arg, appRef);\n    }\n    return {\n        broadcastMessage: broadcastMessage,\n        find: find,\n        scandir: scandir,\n        write: write,\n        read: read,\n        copy: copy,\n        move: move,\n        rename: rename,\n        unlink: unlink,\n        mkdir: mkdir,\n        exists: exists,\n        fileinfo: fileinfo,\n        url: url,\n        upload: upload,\n        download: download,\n        trash: trash,\n        untrash: untrash,\n        emptyTrash: emptyTrash,\n        freeSpace: freeSpace,\n        watch: watch,\n        unwatch: unwatch,\n        triggerWatch: triggerWatch\n    };\n});"]}