{"version":3,"sources":["vfs/fs.js"],"names":["define","FS","FileMetadata","FileDataURL","Process","MountManager","PackageManager","SettingsManager","Connection","Locales","watches","noop","err","res","console","error","warn","hasAlias","item","retm","module","getModuleFromPath","path","match","option","options","alias","replace","checkMetadataArgument","checkRo","TypeError","_","mountpoint","Error","isReadOnly","name","hasSameTransport","src","dest","msrc","mdst","existsWrapper","overwrite","Promise","resolve","reject","exists","then","result","catch","requestWrapper","method","args","appRef","info","arguments","request","response","instance","onVFSRequestCompleted","performRequest","test","errorStr","Object","broadcastMessage","msg","_message","i","message","source","__pid","obj","forEach","w","checkPath","_check","f","type","substr","length","wasTouched","destination","cb","checkWatches","aliased","_transform","n","found","getModules","iter","a","findAlias","tuple","move","e","dialogProgress","prog","dialog","setProgress","promise","sourceMountpoint","destMountpoint","data","find","scandir","vfsSettings","get","oitem","Array","filterScandir","map","isShortcut","shortcut","niter","str","tmp","pathJoin","backlink","back","isOnRoot","split","root","some","filename","dirname","mime","size","createBackLink","unshift","write","convertTo","m","d","toString","window","Blob","convertWriteData","ab","read","types","datasource","yes","no","abToDataSource","dataSource","text","abToText","blob","abToBlob","json","jsn","JSON","parse","stack","toLowerCase","copy","assign","arrayBuffer","rename","unlink","chkdir","generateUserMetadata","mkdir","fileinfo","url","upload","files","all","File","fileDest","download","file","trash","untrash","emptyTrash","freeSpace","watch","callback","push","unwatch","idx","triggerWatch","arg"],"mappings":"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","file":"../../vfs/fs.js","sourcesContent":["define([\n    '../utils/fs',\n    './file',\n    './filedataurl',\n    '../core/process',\n    '../core/mount-manager',\n    '../core/package-manager',\n    '../core/settings-manager',\n    '../core/connection',\n    '../core/locales'\n], function (FS, FileMetadata, FileDataURL, Process, MountManager, PackageManager, SettingsManager, Connection, Locales) {\n    'use strict';\n    let watches = [];\n    function noop(err, res) {\n        if (err) {\n            console.error('VFS operation without callback caused an error', err);\n        } else {\n            console.warn('VFS operation without callback', res);\n        }\n    }\n    function hasAlias(item, retm) {\n        const module = MountManager.getModuleFromPath(item.path);\n        if (module) {\n            const match = module.option('match');\n            const options = module.option('options');\n            if (options && options.alias) {\n                return retm ? module : item.path.replace(match, options.alias);\n            }\n        }\n        return false;\n    }\n    function checkMetadataArgument(item, err, checkRo) {\n        if (typeof item === 'string') {\n            item = new FileMetadata(item);\n        } else if (typeof item === 'object' && item.path) {\n            item = new FileMetadata(item);\n        }\n        if (!(item instanceof FileMetadata)) {\n            throw new TypeError(err || Locales._('ERR_VFS_EXPECT_FILE'));\n        }\n        const alias = hasAlias(item);\n        if (alias) {\n            item.path = alias;\n        }\n        const mountpoint = MountManager.getModuleFromPath(item.path);\n        if (!mountpoint) {\n            throw new Error(Locales._('ERR_VFSMODULE_NOT_FOUND_FMT', item.path));\n        }\n        if (checkRo && mountpoint.isReadOnly()) {\n            throw new Error(Locales._('ERR_VFSMODULE_READONLY_FMT', mountpoint.name));\n        }\n        return item;\n    }\n    function hasSameTransport(src, dest) {\n        const msrc = MountManager.getModuleFromPath(src.path);\n        const mdst = MountManager.getModuleFromPath(dest.path);\n        if (!msrc || !mdst || msrc === mdst) {\n            return true;\n        }\n        if (msrc && mdst && (msrc.option('internal') && mdst.option('internal'))) {\n            return true;\n        }\n        return msrc.option('transport') === mdst.option('tranport');\n    }\n    function existsWrapper(item, options) {\n        options = options || {};\n        if (options.overwrite) {\n            return Promise.resolve();\n        }\n        return new Promise((resolve, reject) => {\n            exists(item).then(result => {\n                if (result) {\n                    return reject(new Error(Locales._('ERR_VFS_FILE_EXISTS')));\n                }\n                return resolve();\n            }).catch(error => {\n                if (error) {\n                    console.warn('existsWrapper() error', error);\n                }\n                reject(error);\n            });\n        });\n    }\n    function createBackLink(item, result, alias, oitem) {\n        const path = item.path.split('://')[1].replace(/\\/+/g, '/').replace(/^\\/?/, '/');\n        let isOnRoot = path === '/';\n        if (alias) {\n            isOnRoot = oitem.path === alias.root;\n        }\n        if (!isOnRoot) {\n            const foundBack = result.some(function (iter) {\n                return iter.filename === '..';\n            });\n            if (!foundBack) {\n                return new FileMetadata({\n                    filename: '..',\n                    path: FS.dirname(item.path),\n                    mime: null,\n                    size: 0,\n                    type: 'dir'\n                });\n            }\n        }\n        return false;\n    }\n    function checkWatches(msg, obj) {\n        watches.forEach(function (w) {\n            const checkPath = w.path;\n            function _check(f) {\n                if (w.type === 'dir') {\n                    return f.path.substr(0, checkPath.length) === checkPath;\n                }\n                return f.path === checkPath;\n            }\n            let wasTouched = false;\n            if (obj.destination) {\n                wasTouched = _check(obj.destination);\n                if (!wasTouched) {\n                    wasTouched = _check(obj.source);\n                }\n            } else {\n                wasTouched = _check(obj);\n            }\n            if (wasTouched) {\n                w.cb(msg, obj);\n            }\n        });\n    }\n    function findAlias(item) {\n        const mm = MountManager;\n        let found = null;\n        mm.getModules().forEach(function (iter) {\n            if (!found && iter.option('options').alias) {\n                const a = iter.option('options').alias;\n                if (item.path.substr(0, a.length) === a) {\n                    found = iter;\n                }\n            }\n        });\n        return found;\n    }\n    function convertWriteData(data, mime) {\n        const convertTo = (m, d, resolve, reject) => {\n            FS[m](d, mime, function (error, response) {\n                if (error) {\n                    reject(new Error(error));\n                } else {\n                    resolve(response);\n                }\n            });\n        };\n        return new Promise((resolve, reject) => {\n            try {\n                if (typeof data === 'string') {\n                    if (data.length) {\n                        return convertTo('textToAb', data, resolve, reject);\n                    }\n                } else {\n                    if (data instanceof FileDataURL) {\n                        return convertTo('dataSourceToAb', data.toString(), resolve, reject);\n                    } else if (window.Blob && data instanceof window.Blob) {\n                        return convertTo('blobToAb', data, resolve, reject);\n                    }\n                }\n            } catch (e) {\n                return reject(e);\n            }\n            return resolve(data);\n        });\n    }\n    function requestWrapper(mountpoint, method, args, options, appRef) {\n        console.info('VFS operation', ...arguments);\n        if (!mountpoint) {\n            return Promise.reject(new Error(Locales._('ERR_VFSMODULE_INVALID')));\n        }\n        return new Promise((resolve, reject) => {\n            mountpoint.request(method, args, options).then(response => {\n                return Connection.instance.onVFSRequestCompleted(mountpoint, method, args, response, appRef).then(() => resolve(response)).catch(reject);\n            }).catch(reject);\n        });\n    }\n    function performRequest(method, args, options, test, appRef, errorStr) {\n        return new Promise((resolve, reject) => {\n            if (options && !(options instanceof Object)) {\n                reject(new TypeError(Locales._('ERR_ARGUMENT_FMT', 'VFS::' + method, 'options', 'Object', typeof options)));\n                return;\n            }\n            const mountpoint = MountManager.getModuleFromPath(test);\n            if (!mountpoint) {\n                reject(new Error(Locales._('ERR_VFSMODULE_NOT_FOUND_FMT', test)));\n                return;\n            }\n            requestWrapper(mountpoint, method, args, options, appRef).then(resolve).catch(reject);\n        });\n    }\n    function broadcastMessage(msg, item, appRef) {\n        function _message(i) {\n            Process.message(msg, i, { source: appRef ? appRef.__pid : null });\n            checkWatches(msg, item);\n        }\n        const aliased = function () {\n            function _transform(i) {\n                if (i instanceof FileMetadata) {\n                    const n = new FileMetadata(i);\n                    const alias = findAlias(n);\n                    if (alias) {\n                        n.path = n.path.replace(alias.option('options').alias, alias.option('root'));\n                        return n;\n                    }\n                }\n                return false;\n            }\n            if (item instanceof FileMetadata) {\n                return _transform(item);\n            } else if (item && item.destination && item.source) {\n                return {\n                    source: _transform(item.source),\n                    destination: _transform(item.destination)\n                };\n            }\n            return null;\n        }();\n        _message(item);\n        const tuple = aliased.source || aliased.destination;\n        if (aliased && (aliased instanceof FileMetadata || tuple)) {\n            if (tuple) {\n                aliased.source = aliased.source || item.source;\n                aliased.destination = aliased.destination || item.destination;\n            }\n            _message(aliased);\n        }\n    }\n    function find(item, args, options) {\n        options = options || {};\n        if (arguments.length < 2) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('find', [\n            item,\n            args\n        ], options, item.path, null, 'ERR_VFSMODULE_FIND_FMT');\n    }\n    function scandir(item, options) {\n        const vfsSettings = SettingsManager.get('VFS');\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        const oitem = new FileMetadata(item);\n        const alias = hasAlias(oitem, true);\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return new Promise((resolve, reject) => {\n            performRequest('scandir', [item], options, item.path, null, 'ERR_VFSMODULE_SCANDIR_FMT').then(result => {\n                if (result instanceof Array) {\n                    result = FS.filterScandir(result, options, vfsSettings);\n                    if (alias) {\n                        result = result.map(function (iter) {\n                            const isShortcut = iter.shortcut === true;\n                            const niter = new FileMetadata(iter);\n                            if (!isShortcut) {\n                                const str = iter.path.replace(/\\/?$/, '');\n                                const opt = alias.option('options') || {};\n                                const tmp = opt.alias.replace(/\\/?$/, '');\n                                niter.path = FS.pathJoin(alias.option('root'), str.replace(tmp, ''));\n                            }\n                            return niter;\n                        });\n                    }\n                    if (options.backlink !== false) {\n                        const back = createBackLink(item, result, alias, oitem);\n                        if (back) {\n                            result.unshift(back);\n                        }\n                    }\n                }\n                return resolve(result);\n            }).catch(reject);\n        });\n    }\n    function write(item, data, options, appRef) {\n        options = options || {};\n        if (arguments.length < 2) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item, null, true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return new Promise((resolve, reject) => {\n            const mountpoint = MountManager.getModuleFromPath(item.path);\n            convertWriteData(data, item.mime).then(ab => {\n                requestWrapper(mountpoint, 'write', [\n                    item,\n                    ab\n                ], options, appRef).then(resolve).catch(e => {\n                    reject(new Error(Locales._('ERR_VFSMODULE_WRITE_FMT', e)));\n                });\n                return true;\n            }).catch(e => {\n                reject(new Error(Locales._('ERR_VFSMODULE_WRITE_FMT', e)));\n            });\n        });\n    }\n    function read(item, options) {\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return new Promise((resolve, reject) => {\n            const mountpoint = MountManager.getModuleFromPath(item.path);\n            requestWrapper(mountpoint, 'read', [item], options).then(response => {\n                if (options.type) {\n                    const types = {\n                        datasource: () => new Promise((yes, no) => {\n                            FS.abToDataSource(response, item.mime, function (error, dataSource) {\n                                return error ? no(error) : yes(dataSource);\n                            });\n                        }),\n                        text: () => new Promise((yes, no) => {\n                            FS.abToText(response, item.mime, function (error, text) {\n                                return error ? no(error) : yes(text);\n                            });\n                        }),\n                        blob: () => new Promise((yes, no) => {\n                            FS.abToBlob(response, item.mime, function (error, blob) {\n                                return error ? no(error) : yes(blob);\n                            });\n                        }),\n                        json: () => new Promise((yes, no) => {\n                            FS.abToText(response, item.mime, function (error, text) {\n                                let jsn;\n                                if (typeof text === 'string') {\n                                    try {\n                                        jsn = JSON.parse(text);\n                                    } catch (e) {\n                                        console.warn('VFS::read()', 'readToJSON', e.stack, e);\n                                    }\n                                }\n                                return error ? no(error) : yes(jsn);\n                            });\n                        })\n                    };\n                    const type = options.type.toLowerCase();\n                    if (types[type]) {\n                        return types[type]().then(resolve).catch(reject);\n                    }\n                }\n                return resolve(response);\n            }).catch(e => {\n                reject(new Error(Locales._('ERR_VFSMODULE_READ_FMT', e)));\n            });\n        });\n    }\n    function copy(src, dest, options, appRef) {\n        options = options || {};\n        if (arguments.length < 2) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            src = checkMetadataArgument(src, Locales._('ERR_VFS_EXPECT_SRC_FILE'));\n            dest = checkMetadataArgument(dest, Locales._('ERR_VFS_EXPECT_DST_FILE'), true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        options = Object.assign({}, {\n            type: 'binary',\n            dialog: null\n        }, options);\n        options.arrayBuffer = true;\n        function dialogProgress(prog) {\n            if (options.dialog) {\n                options.dialog.setProgress(prog);\n            }\n        }\n        const promise = new Promise((resolve, reject) => {\n            existsWrapper(dest, options).then(() => {\n                const sourceMountpoint = MountManager.getModuleFromPath(src.path);\n                const destMountpoint = MountManager.getModuleFromPath(dest.path);\n                if (hasSameTransport(src, dest)) {\n                    requestWrapper(sourceMountpoint, 'copy', [\n                        src,\n                        dest\n                    ], options, appRef).then(() => {\n                        dialogProgress(100);\n                        return resolve(true);\n                    }).catch(reject);\n                } else {\n                    requestWrapper(sourceMountpoint, 'read', [src], options, appRef).then(data => {\n                        dialogProgress(50);\n                        return requestWrapper(destMountpoint, 'write', [\n                            dest,\n                            data\n                        ], options, appRef).then(res => {\n                            dialogProgress(100);\n                            return resolve(res);\n                        }).catch(reject);\n                    }).catch(reject);\n                }\n                return true;\n            }).catch(reject);\n        });\n        return new Promise((resolve, reject) => {\n            promise.then(resolve).catch(e => {\n                dialogProgress(100);\n                reject(new Error(Locales._('ERR_VFSMODULE_COPY_FMT', e)));\n            });\n        });\n    }\n    function move(src, dest, options, appRef) {\n        options = options || {};\n        if (arguments.length < 2) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            src = checkMetadataArgument(src, Locales._('ERR_VFS_EXPECT_SRC_FILE'));\n            dest = checkMetadataArgument(dest, Locales._('ERR_VFS_EXPECT_DST_FILE'), true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        function dialogProgress(prog) {\n            if (options.dialog) {\n                options.dialog.setProgress(prog);\n            }\n        }\n        const promise = new Promise((resolve, reject) => {\n            existsWrapper(dest, options).then(() => {\n                const sourceMountpoint = MountManager.getModuleFromPath(src.path);\n                const destMountpoint = MountManager.getModuleFromPath(dest.path);\n                if (hasSameTransport(src, dest)) {\n                    requestWrapper(sourceMountpoint, 'move', [\n                        src,\n                        dest\n                    ], options, appRef).then(() => {\n                        dialogProgress(100);\n                        return resolve(true);\n                    }).catch(reject);\n                } else {\n                    requestWrapper(sourceMountpoint, 'read', [src], options, appRef).then(data => {\n                        dialogProgress(50);\n                        return requestWrapper(destMountpoint, 'write', [\n                            dest,\n                            data\n                        ], options, appRef).then(res => {\n                            return requestWrapper(sourceMountpoint, 'unlink', [src], options, appRef).then(res => {\n                                dialogProgress(100);\n                                return resolve(res);\n                            }).catch(reject);\n                        }).catch(reject);\n                    }).catch(reject);\n                }\n                return true;\n            }).catch(reject);\n        });\n        return new Promise((resolve, reject) => {\n            promise.then(resolve).catch(e => {\n                dialogProgress(100);\n                reject(new Error(Locales._('ERR_VFSMODULE_MOVE_FMT', e)));\n            });\n        });\n    }\n    function rename(src, dest) {\n        return move(...arguments);\n    }\n    function unlink(item, options, appRef) {\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item, null, true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return new Promise((resolve, reject) => {\n            performRequest('unlink', [item], options, item.path, appRef, 'ERR_VFSMODULE_UNLINK_FMT').then(response => {\n                const pkgdir = SettingsManager.instance('PackageManager').get('PackagePaths', []);\n                const found = pkgdir.some(function (i) {\n                    const chkdir = new FileMetadata(i);\n                    const idir = FS.dirname(item.path);\n                    return idir === chkdir.path;\n                });\n                if (found) {\n                    PackageManager.generateUserMetadata(function () {\n                    });\n                }\n                return resolve(response);\n            }).catch(reject);\n        });\n    }\n    function mkdir(item, options, appRef) {\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item, null, true);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('mkdir', [item], options, item.path, appRef, 'ERR_VFSMODULE_MKDIR_FMT');\n    }\n    function exists(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('exists', [item], {}, item.path, null, 'ERR_VFSMODULE_EXISTS_FMT');\n    }\n    function fileinfo(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('fileinfo', [item], {}, item.path, null, 'ERR_VFSMODULE_FILEINFO_FMT');\n    }\n    function url(item, options) {\n        options = options || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('url', [item], options, item.path, null, 'ERR_VFSMODULE_URL_FMT');\n    }\n    function upload(args, options, appRef) {\n        args = args || {};\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        if (!args.files) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_UPLOAD_NO_FILES')));\n        }\n        if (!args.destination) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_UPLOAD_NO_DEST')));\n        }\n        const dest = new FileMetadata(args.destination);\n        const mountpoint = MountManager.getModuleFromPath(args.destination);\n        return new Promise((resolve, reject) => {\n            Promise.all(args.files.map(f => {\n                const filename = f instanceof window.File ? f.name : f.filename;\n                const fileDest = new FileMetadata(FS.pathJoin(args.destination, filename));\n                return new Promise((resolve, reject) => {\n                    existsWrapper(fileDest, options).then(() => {\n                        return requestWrapper(mountpoint, 'upload', [\n                            dest,\n                            f\n                        ], options, appRef).then(resolve).catch(reject);\n                    }).catch(reject);\n                });\n            })).then(resolve).catch(e => {\n                reject(new Error(Locales._('ERR_VFS_UPLOAD_FAIL_FMT', e)));\n            });\n        });\n    }\n    function download(file) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            file = checkMetadataArgument(file);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        if (!file.path) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_DOWNLOAD_NO_FILE')));\n        }\n        const promise = new Promise((resolve, reject) => {\n            const mountpoint = MountManager.getModuleFromPath(file);\n            requestWrapper(mountpoint, 'download', [file], {}).then(() => {\n                if (mountpoint.option('internal')) {\n                    mountpoint.download(file).then(resolve).catch(reject);\n                } else {\n                    mountpoint.read(file).then(resolve).catch(reject);\n                }\n                return true;\n            });\n        });\n        return new Promise((resolve, reject) => {\n            promise.then(resolve).catch(e => {\n                reject(new Error(Locales._('ERR_VFS_DOWNLOAD_FAILED', e)));\n            });\n        });\n    }\n    function trash(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('trash', [item], {}, item.path, null, 'ERR_VFSMODULE_TRASH_FMT');\n    }\n    function untrash(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return performRequest('untrash', [item], {}, item.path, null, 'ERR_VFSMODULE_UNTRASH_FMT');\n    }\n    function emptyTrash() {\n        return performRequest('emptyTrash', [], {}, null, null, 'ERR_VFSMODULE_EMPTYTRASH_FMT');\n    }\n    function freeSpace(item) {\n        if (arguments.length < 1) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_NUM_ARGS')));\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        const m = MountManager.getModuleFromPath(item.path, false, true);\n        return performRequest('freeSpace', [m.option('root')], {}, item.path, null, 'ERR_VFSMODULE_FREESPACE_FMT');\n    }\n    function watch(item, callback) {\n        callback = callback || noop;\n        if (arguments.length < 2) {\n            callback(Locales._('ERR_VFS_NUM_ARGS'));\n            return -1;\n        }\n        try {\n            item = checkMetadataArgument(item);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return Promise.resolve(watches.push({\n            path: item.path,\n            type: item.type,\n            cb: callback\n        }) - 1);\n    }\n    function unwatch(idx) {\n        if (typeof watches[idx] !== 'undefined') {\n            delete watches[idx];\n        }\n    }\n    function triggerWatch(method, arg, appRef) {\n        broadcastMessage('vfs:' + method, arg, appRef);\n    }\n    return {\n        broadcastMessage: broadcastMessage,\n        find: find,\n        scandir: scandir,\n        write: write,\n        read: read,\n        copy: copy,\n        move: move,\n        rename: rename,\n        unlink: unlink,\n        mkdir: mkdir,\n        exists: exists,\n        fileinfo: fileinfo,\n        url: url,\n        upload: upload,\n        download: download,\n        trash: trash,\n        untrash: untrash,\n        emptyTrash: emptyTrash,\n        freeSpace: freeSpace,\n        watch: watch,\n        unwatch: unwatch,\n        triggerWatch: triggerWatch\n    };\n});"]}