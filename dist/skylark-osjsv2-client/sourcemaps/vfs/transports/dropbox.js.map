{"version":3,"sources":["vfs/transports/dropbox.js"],"names":["define","Transport","Preloader","a","FileMetadata","b","c","FS","[object Object]","super","arguments","this","loaded","authed","dbx","Promise","resolve","reject","preload","then","window","Dropbox","Error","_","catch","err","clientId","timedOut","loginTimeout","redirectUrl","location","href","replace","url","clearTimeout","params","urlparams","access_token","accessToken","authUrl","getAuthenticationUrl","setTimeout","open","getConfig","_loadDependencies","_createClient","method","args","options","mount","fargs","_init","request","status","response","error","error_summary","root","iter","id","filename","name","path","pathJoin","path_display","type","size","file","getPathFromVirtual","filesSearch","query","max_results","mode",".tag","matches","map","_createMetadata","option","metadata","item","result","scandir","cursor","m","found","entries","concat","has_more","dl","sharingGetSharedLinkFile","data","fileBlob","filesUpload","contents","src","dest","filesCopy","from_path","to_path","filesMove","fileinfo","filesGetMetadata","hasLink","sharingGetSharedLinks","links","length","find","visibility","String","newLink","sharingCreateSharedLinkWithSettings","settings","requested_visibility","console","warn","dir","filesCreateFolder","mime","write","usersGetSpaceUsage","allocation","individual","allocated","e","filesDelete"],"mappings":"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","file":"../../../vfs/transports/dropbox.js","sourcesContent":["define([\n    '../transport',\n    '../../utils/preloader',\n    '../../core/config',\n    '../file',\n    '../../utils/misc',\n    '../../core/locales',\n    '../../utils/fs'\n], function (Transport, Preloader, a, FileMetadata, b, c, FS) {\n    'use strict';\n    const AUTH_TIMEOUT = 1000 * 30;\n    const MAX_RESULTS = 100;\n    return class DropboxTransport extends Transport {\n        constructor() {\n            super(...arguments);\n            this.loaded = false;\n            this.authed = false;\n            this.dbx = null;\n        }\n        _loadDependencies() {\n            if (this.loaded) {\n                return Promise.resolve(true);\n            }\n            return new Promise((resolve, reject) => {\n                Preloader.preload(['https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js']).then(() => {\n                    if (window.Dropbox) {\n                        this.loaded = true;\n                        return resolve(true);\n                    }\n                    return reject(new Error(c._('ERR_DROPBOX_API')));\n                }).catch(err => {\n                    this.loaded = true;\n                    return reject(err);\n                });\n            });\n        }\n        _createClient(clientId) {\n            if (this.authed) {\n                return Promise.resolve(true);\n            }\n            return new Promise((resolve, reject) => {\n                let timedOut;\n                let loginTimeout;\n                this.dbx = new window.Dropbox({ clientId: clientId });\n                const redirectUrl = window.location.href.replace(/\\/?$/, '/') + 'dropbox-oauth.html';\n                const callbackName = '__osjs__dropbox_callback__';\n                window[callbackName] = url => {\n                    clearTimeout(loginTimeout);\n                    if (timedOut) {\n                        return;\n                    }\n                    const params = b.urlparams(url, true);\n                    if (params.access_token) {\n                        this.authed = true;\n                        this.dbx = new window.Dropbox({ accessToken: params.access_token });\n                        resolve(true);\n                    } else {\n                        reject(new Error(c._('ERR_DROPBOX_AUTH')));\n                    }\n                };\n                const authUrl = this.dbx.getAuthenticationUrl(redirectUrl);\n                loginTimeout = setTimeout(() => {\n                    timedOut = true;\n                    reject(new Error(c._('ERR_DROPBOX_AUTH')));\n                }, AUTH_TIMEOUT);\n                window.open(authUrl);\n            });\n        }\n        _init() {\n            const clientId = a.getConfig('DropboxAPI.ClientKey');\n            if (!clientId) {\n                return Promise.reject(new Error(c._('ERR_DROPBOX_KEY')));\n            }\n            return new Promise((resolve, reject) => {\n                this._loadDependencies().then(() => {\n                    return this._createClient(clientId).then(resolve).catch(reject);\n                }).catch(reject);\n            });\n        }\n        request(method, args, options, mount) {\n            const fargs = arguments;\n            return new Promise((resolve, reject) => {\n                this._init().then(() => {\n                    return super.request(...fargs).then(resolve).catch(err => {\n                        if (typeof err !== 'string' && !(err instanceof Error)) {\n                            if (err.status && err.response && err.error) {\n                                return reject(new Error(err.error.error_summary));\n                            }\n                        }\n                        return reject(err);\n                    });\n                }).catch(reject);\n            });\n        }\n        _createMetadata(root, iter) {\n            return {\n                id: iter.id,\n                filename: iter.name,\n                path: FS.pathJoin(root, iter.path_display),\n                type: iter['.tag'] === 'folder' ? 'dir' : 'file',\n                size: iter.size || 0\n            };\n        }\n        find(file, options, a, mount) {\n            const root = FS.getPathFromVirtual(file.path);\n            return new Promise((resolve, reject) => {\n                this.dbx.filesSearch({\n                    path: root === '/' ? '' : root,\n                    query: options.query,\n                    max_results: MAX_RESULTS,\n                    mode: { '.tag': 'filename' }\n                }).then(response => {\n                    return resolve(response.matches.map(iter => {\n                        return this._createMetadata(mount.option('root'), iter.metadata);\n                    }));\n                }).catch(reject);\n            });\n        }\n        scandir(item, options, mount) {\n            const root = FS.getPathFromVirtual(item.path);\n            let result = [];\n            const scandir = cursor => new Promise((resolve, reject) => {\n                const m = cursor ? 'filesListFolderContinue' : 'filesListFolder';\n                const a = cursor ? { cursor } : { path: root === '/' ? '' : root };\n                this.dbx[m](a).then(response => {\n                    const found = (response.entries || []).map(iter => {\n                        return this._createMetadata(mount.option('root'), iter);\n                    });\n                    result = result.concat(found);\n                    if (response.has_more && response.cursor) {\n                        return scandir(response.cursor).then(resolve).catch(reject);\n                    }\n                    return resolve(result);\n                }).catch(reject);\n            });\n            return scandir(null);\n        }\n        read(item, options, mount) {\n            return new Promise((resolve, reject) => {\n                this.url(item, { dl: 0 }).then(url => {\n                    this.dbx.sharingGetSharedLinkFile({ url }).then(data => {\n                        return resolve(data.fileBlob);\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n        write(file, data) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesUpload({\n                    path: FS.getPathFromVirtual(file.path),\n                    mode: { '.tag': 'overwrite' },\n                    contents: data\n                }).then(() => resolve(true)).catch(reject);\n            });\n        }\n        copy(src, dest) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesCopy({\n                    from_path: FS.getPathFromVirtual(src.path),\n                    to_path: FS.getPathFromVirtual(dest.path)\n                }).then(() => resolve(true)).catch(reject);\n            });\n        }\n        move(src, dest) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesMove({\n                    from_path: FS.getPathFromVirtual(src.path),\n                    to_path: FS.getPathFromVirtual(dest.path)\n                }).then(() => resolve(true)).catch(reject);\n            });\n        }\n        exists(item) {\n            return new Promise((resolve, reject) => {\n                this.fileinfo(item).then(() => resolve(true)).catch(() => resolve(false));\n            });\n        }\n        fileinfo(item) {\n            return this.dbx.filesGetMetadata({ path: FS.getPathFromVirtual(item.path) });\n        }\n        url(item, options) {\n            const visibility = 'public';\n            const hasLink = () => new Promise((resolve, reject) => {\n                this.dbx.sharingGetSharedLinks({ path: FS.getPathFromVirtual(item.path) }).then(response => {\n                    if (response.links.length) {\n                        const found = response.links.find(iter => iter.visibility['.tag'] === visibility);\n                        const dl = typeof options.dl === 'undefined' ? 1 : options.dl;\n                        if (found) {\n                            return resolve(found.url.replace('dl=0', 'dl=' + String(dl)));\n                        }\n                    }\n                    return resolve(false);\n                }).catch(reject);\n            });\n            const newLink = () => new Promise((resolve, reject) => {\n                this.dbx.sharingCreateSharedLinkWithSettings({\n                    path: FS.getPathFromVirtual(item.path),\n                    settings: { requested_visibility: visibility }\n                }).then(response => {\n                    return resolve(response.url);\n                }).catch(reject);\n            });\n            return new Promise((resolve, reject) => {\n                hasLink().then(url => {\n                    if (url) {\n                        console.warn('ALREADY HAS URL', url);\n                        return resolve(url);\n                    }\n                    console.warn('CREATING NEW URL');\n                    return newLink().then(resolve).catch(reject);\n                }).catch(reject);\n            });\n        }\n        mkdir(dir) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesCreateFolder({ path: FS.getPathFromVirtual(dir.path) }).then(() => resolve(true)).catch(reject);\n            });\n        }\n        upload(dest, file) {\n            const item = new FileMetadata({\n                filename: file.name,\n                path: FS.pathJoin(dest.path, file.name),\n                mime: file.type,\n                size: file.size\n            });\n            return this.write(item, file);\n        }\n        freeSpace(root) {\n            return new Promise((resolve, reject) => {\n                this.dbx.usersGetSpaceUsage().then(response => {\n                    try {\n                        if (response.allocation && typeof response.allocation.individual !== 'undefined') {\n                            return resolve(response.allocation.individual.allocated);\n                        }\n                    } catch (e) {\n                        console.warn(e);\n                    }\n                    return resolve(-1);\n                }).catch(reject);\n            });\n        }\n        unlink(src) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesDelete({ path: FS.getPathFromVirtual(src.path) }).then(() => resolve(true)).catch(reject);\n            });\n        }\n    };\n});"]}