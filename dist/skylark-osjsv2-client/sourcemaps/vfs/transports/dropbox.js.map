{"version":3,"sources":["vfs/transports/dropbox.js"],"names":["define","Transport","Preloader","Config","FileMetadata","b","Locales","FS","[object Object]","super","arguments","this","loaded","authed","dbx","Promise","resolve","reject","preload","then","window","Dropbox","Error","_","catch","err","clientId","timedOut","loginTimeout","redirectUrl","location","href","replace","url","clearTimeout","params","urlparams","access_token","accessToken","authUrl","getAuthenticationUrl","setTimeout","open","getConfig","_loadDependencies","_createClient","method","args","options","mount","fargs","_init","request","status","response","error","error_summary","root","iter","id","filename","name","path","pathJoin","path_display","type","size","file","a","getPathFromVirtual","filesSearch","query","max_results","mode",".tag","matches","map","_createMetadata","option","metadata","item","result","scandir","cursor","m","found","entries","concat","has_more","dl","sharingGetSharedLinkFile","data","fileBlob","filesUpload","contents","src","dest","filesCopy","from_path","to_path","filesMove","fileinfo","filesGetMetadata","hasLink","sharingGetSharedLinks","links","length","find","visibility","String","newLink","sharingCreateSharedLinkWithSettings","settings","requested_visibility","console","warn","dir","filesCreateFolder","mime","write","usersGetSpaceUsage","allocation","individual","allocated","e","filesDelete"],"mappings":";;;;;;;AAAAA,QACI,eACA,wBACA,oBACA,UACA,mBACA,qBACA,kBACD,SAAUC,EAAWC,EAAWC,EAAQC,EAAcC,EAAGC,EAASC,GACjE,aAGA,qBAAsCN,EAClCO,cACIC,SAASC,WACTC,KAAKC,QAAS,EACdD,KAAKE,QAAS,EACdF,KAAKG,IAAM,KAEfN,oBACI,OAAIG,KAAKC,OACEG,QAAQC,SAAQ,GAEpB,IAAID,QAAQ,CAACC,EAASC,KACzBf,EAAUgB,SAAS,sDAAsDC,KAAK,IACtEC,OAAOC,SACPV,KAAKC,QAAS,EACPI,GAAQ,IAEZC,EAAO,IAAIK,MAAMhB,EAAQiB,EAAE,sBACnCC,MAAMC,IACLd,KAAKC,QAAS,EACPK,EAAOQ,OAI1BjB,cAAckB,GACV,OAAIf,KAAKE,OACEE,QAAQC,SAAQ,GAEpB,IAAID,QAAQ,CAACC,EAASC,KACzB,IAAIU,EACAC,EACJjB,KAAKG,IAAM,IAAIM,OAAOC,SAAUK,SAAUA,IAC1C,MAAMG,EAAcT,OAAOU,SAASC,KAAKC,QAAQ,OAAQ,KAAO,qBAEhEZ,OAAmB,2BAAIa,CAAAA,IAEnB,GADAC,aAAaN,GACTD,EACA,OAEJ,MAAMQ,EAAS9B,EAAE+B,UAAUH,GAAK,GAC5BE,EAAOE,cACP1B,KAAKE,QAAS,EACdF,KAAKG,IAAM,IAAIM,OAAOC,SAAUiB,YAAaH,EAAOE,eACpDrB,GAAQ,IAERC,EAAO,IAAIK,MAAMhB,EAAQiB,EAAE,wBAGnC,MAAMgB,EAAU5B,KAAKG,IAAI0B,qBAAqBX,GAC9CD,EAAea,WAAW,KACtBd,GAAW,EACXV,EAAO,IAAIK,MAAMhB,EAAQiB,EAAE,uBArDtB,KAuDTH,OAAOsB,KAAKH,KAGpB/B,QACI,MAAMkB,EAAWvB,EAAOwC,UAAU,wBAClC,OAAKjB,EAGE,IAAIX,QAAQ,CAACC,EAASC,KACzBN,KAAKiC,oBAAoBzB,KAAK,IACnBR,KAAKkC,cAAcnB,GAAUP,KAAKH,GAASQ,MAAMP,IACzDO,MAAMP,KALFF,QAAQE,OAAO,IAAIK,MAAMhB,EAAQiB,EAAE,qBAQlDf,QAAQsC,EAAQC,EAAMC,EAASC,GAC3B,MAAMC,EAAQxC,UACd,OAAO,IAAIK,QAAQ,CAACC,EAASC,KACzBN,KAAKwC,QAAQhC,KAAK,IACPV,MAAM2C,WAAWF,GAAO/B,KAAKH,GAASQ,MAAMC,GAC5B,iBAARA,KAAsBA,aAAeH,QACxCG,EAAI4B,QAAU5B,EAAI6B,UAAY7B,EAAI8B,MAC3BtC,EAAO,IAAIK,MAAMG,EAAI8B,MAAMC,gBAGnCvC,EAAOQ,KAEnBD,MAAMP,KAGjBT,gBAAgBiD,EAAMC,GAClB,OACIC,GAAID,EAAKC,GACTC,SAAUF,EAAKG,KACfC,KAAMvD,EAAGwD,SAASN,EAAMC,EAAKM,cAC7BC,KAAuB,WAAjBP,EAAK,QAAuB,MAAQ,OAC1CQ,KAAMR,EAAKQ,MAAQ,GAG3B1D,KAAK2D,EAAMnB,EAASoB,EAAGnB,GACnB,MAAMQ,EAAOlD,EAAG8D,mBAAmBF,EAAKL,MACxC,OAAO,IAAI/C,QAAQ,CAACC,EAASC,KACzBN,KAAKG,IAAIwD,aACLR,KAAe,MAATL,EAAe,GAAKA,EAC1Bc,MAAOvB,EAAQuB,MACfC,YAlGI,IAmGJC,MAAQC,OAAQ,cACjBvD,KAAKmC,GACGtC,EAAQsC,EAASqB,QAAQC,IAAIlB,GACzB/C,KAAKkE,gBAAgB5B,EAAM6B,OAAO,QAASpB,EAAKqB,aAE5DvD,MAAMP,KAGjBT,QAAQwE,EAAMhC,EAASC,GACnB,MAAMQ,EAAOlD,EAAG8D,mBAAmBW,EAAKlB,MACxC,IAAImB,KACJ,MAAMC,EAAUC,GAAU,IAAIpE,QAAQ,CAACC,EAASC,KAC5C,MAAMmE,EAAID,EAAS,0BAA4B,kBACzCf,EAAIe,GAAWA,OAAAA,IAAarB,KAAe,MAATL,EAAe,GAAKA,GAC5D9C,KAAKG,IAAIsE,GAAGhB,GAAGjD,KAAKmC,IAChB,MAAM+B,GAAS/B,EAASgC,aAAeV,IAAIlB,GAChC/C,KAAKkE,gBAAgB5B,EAAM6B,OAAO,QAASpB,IAGtD,OADAuB,EAASA,EAAOM,OAAOF,GACnB/B,EAASkC,UAAYlC,EAAS6B,OACvBD,EAAQ5B,EAAS6B,QAAQhE,KAAKH,GAASQ,MAAMP,GAEjDD,EAAQiE,KAChBzD,MAAMP,KAEb,OAAOiE,EAAQ,MAEnB1E,KAAKwE,EAAMhC,EAASC,GAChB,OAAO,IAAIlC,QAAQ,CAACC,EAASC,KACzBN,KAAKsB,IAAI+C,GAAQS,GAAI,IAAKtE,KAAKc,IAC3BtB,KAAKG,IAAI4E,0BAA2BzD,IAAAA,IAAOd,KAAKwE,GACrC3E,EAAQ2E,EAAKC,WACrBpE,MAAMP,KACVO,MAAMP,KAGjBT,MAAM2D,EAAMwB,GACR,OAAO,IAAI5E,QAAQ,CAACC,EAASC,KACzBN,KAAKG,IAAI+E,aACL/B,KAAMvD,EAAG8D,mBAAmBF,EAAKL,MACjCW,MAAQC,OAAQ,aAChBoB,SAAUH,IACXxE,KAAK,IAAMH,GAAQ,IAAOQ,MAAMP,KAG3CT,KAAKuF,EAAKC,GACN,OAAO,IAAIjF,QAAQ,CAACC,EAASC,KACzBN,KAAKG,IAAImF,WACLC,UAAW3F,EAAG8D,mBAAmB0B,EAAIjC,MACrCqC,QAAS5F,EAAG8D,mBAAmB2B,EAAKlC,QACrC3C,KAAK,IAAMH,GAAQ,IAAOQ,MAAMP,KAG3CT,KAAKuF,EAAKC,GACN,OAAO,IAAIjF,QAAQ,CAACC,EAASC,KACzBN,KAAKG,IAAIsF,WACLF,UAAW3F,EAAG8D,mBAAmB0B,EAAIjC,MACrCqC,QAAS5F,EAAG8D,mBAAmB2B,EAAKlC,QACrC3C,KAAK,IAAMH,GAAQ,IAAOQ,MAAMP,KAG3CT,OAAOwE,GACH,OAAO,IAAIjE,QAAQ,CAACC,EAASC,KACzBN,KAAK0F,SAASrB,GAAM7D,KAAK,IAAMH,GAAQ,IAAOQ,MAAM,IAAMR,GAAQ,MAG1ER,SAASwE,GACL,OAAOrE,KAAKG,IAAIwF,kBAAmBxC,KAAMvD,EAAG8D,mBAAmBW,EAAKlB,QAExEtD,IAAIwE,EAAMhC,GACN,MACMuD,EAAU,IAAM,IAAIxF,QAAQ,CAACC,EAASC,KACxCN,KAAKG,IAAI0F,uBAAwB1C,KAAMvD,EAAG8D,mBAAmBW,EAAKlB,QAAS3C,KAAKmC,IAC5E,GAAIA,EAASmD,MAAMC,OAAQ,CACvB,MAAMrB,EAAQ/B,EAASmD,MAAME,KAAKjD,GAJ3B,WAImCA,EAAKkD,WAAW,SACpDnB,OAA2B,IAAfzC,EAAQyC,GAAqB,EAAIzC,EAAQyC,GAC3D,GAAIJ,EACA,OAAOrE,EAAQqE,EAAMpD,IAAID,QAAQ,OAAQ,MAAQ6E,OAAOpB,KAGhE,OAAOzE,GAAQ,KAChBQ,MAAMP,KAEP6F,EAAU,IAAM,IAAI/F,QAAQ,CAACC,EAASC,KACxCN,KAAKG,IAAIiG,qCACLjD,KAAMvD,EAAG8D,mBAAmBW,EAAKlB,MACjCkD,UAAYC,qBAhBD,YAiBZ9F,KAAKmC,GACGtC,EAAQsC,EAASrB,MACzBT,MAAMP,KAEb,OAAO,IAAIF,QAAQ,CAACC,EAASC,KACzBsF,IAAUpF,KAAKc,GACPA,GACAiF,QAAQC,KAAK,kBAAmBlF,GACzBjB,EAAQiB,KAEnBiF,QAAQC,KAAK,oBACNL,IAAU3F,KAAKH,GAASQ,MAAMP,KACtCO,MAAMP,KAGjBT,MAAM4G,GACF,OAAO,IAAIrG,QAAQ,CAACC,EAASC,KACzBN,KAAKG,IAAIuG,mBAAoBvD,KAAMvD,EAAG8D,mBAAmB+C,EAAItD,QAAS3C,KAAK,IAAMH,GAAQ,IAAOQ,MAAMP,KAG9GT,OAAOwF,EAAM7B,GACT,MAAMa,EAAO,IAAI5E,GACbwD,SAAUO,EAAKN,KACfC,KAAMvD,EAAGwD,SAASiC,EAAKlC,KAAMK,EAAKN,MAClCyD,KAAMnD,EAAKF,KACXC,KAAMC,EAAKD,OAEf,OAAOvD,KAAK4G,MAAMvC,EAAMb,GAE5B3D,UAAUiD,GACN,OAAO,IAAI1C,QAAQ,CAACC,EAASC,KACzBN,KAAKG,IAAI0G,qBAAqBrG,KAAKmC,IAC/B,IACI,GAAIA,EAASmE,iBAAwD,IAAnCnE,EAASmE,WAAWC,WAClD,OAAO1G,EAAQsC,EAASmE,WAAWC,WAAWC,WAEpD,MAAOC,GACLV,QAAQC,KAAKS,GAEjB,OAAO5G,GAAS,KACjBQ,MAAMP,KAGjBT,OAAOuF,GACH,OAAO,IAAIhF,QAAQ,CAACC,EAASC,KACzBN,KAAKG,IAAI+G,aAAc/D,KAAMvD,EAAG8D,mBAAmB0B,EAAIjC,QAAS3C,KAAK,IAAMH,GAAQ,IAAOQ,MAAMP","file":"../../../vfs/transports/dropbox.js","sourcesContent":["define([\n    '../transport',\n    '../../utils/preloader',\n    '../../core/config',\n    '../file',\n    '../../utils/misc',\n    '../../core/locales',\n    '../../utils/fs'\n], function (Transport, Preloader, Config, FileMetadata, b, Locales, FS) {\n    'use strict';\n    const AUTH_TIMEOUT = 1000 * 30;\n    const MAX_RESULTS = 100;\n    return class DropboxTransport extends Transport {\n        constructor() {\n            super(...arguments);\n            this.loaded = false;\n            this.authed = false;\n            this.dbx = null;\n        }\n        _loadDependencies() {\n            if (this.loaded) {\n                return Promise.resolve(true);\n            }\n            return new Promise((resolve, reject) => {\n                Preloader.preload(['https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js']).then(() => {\n                    if (window.Dropbox) {\n                        this.loaded = true;\n                        return resolve(true);\n                    }\n                    return reject(new Error(Locales._('ERR_DROPBOX_API')));\n                }).catch(err => {\n                    this.loaded = true;\n                    return reject(err);\n                });\n            });\n        }\n        _createClient(clientId) {\n            if (this.authed) {\n                return Promise.resolve(true);\n            }\n            return new Promise((resolve, reject) => {\n                let timedOut;\n                let loginTimeout;\n                this.dbx = new window.Dropbox({ clientId: clientId });\n                const redirectUrl = window.location.href.replace(/\\/?$/, '/') + 'dropbox-oauth.html';\n                const callbackName = '__osjs__dropbox_callback__';\n                window[callbackName] = url => {\n                    clearTimeout(loginTimeout);\n                    if (timedOut) {\n                        return;\n                    }\n                    const params = b.urlparams(url, true);\n                    if (params.access_token) {\n                        this.authed = true;\n                        this.dbx = new window.Dropbox({ accessToken: params.access_token });\n                        resolve(true);\n                    } else {\n                        reject(new Error(Locales._('ERR_DROPBOX_AUTH')));\n                    }\n                };\n                const authUrl = this.dbx.getAuthenticationUrl(redirectUrl);\n                loginTimeout = setTimeout(() => {\n                    timedOut = true;\n                    reject(new Error(Locales._('ERR_DROPBOX_AUTH')));\n                }, AUTH_TIMEOUT);\n                window.open(authUrl);\n            });\n        }\n        _init() {\n            const clientId = Config.getConfig('DropboxAPI.ClientKey');\n            if (!clientId) {\n                return Promise.reject(new Error(Locales._('ERR_DROPBOX_KEY')));\n            }\n            return new Promise((resolve, reject) => {\n                this._loadDependencies().then(() => {\n                    return this._createClient(clientId).then(resolve).catch(reject);\n                }).catch(reject);\n            });\n        }\n        request(method, args, options, mount) {\n            const fargs = arguments;\n            return new Promise((resolve, reject) => {\n                this._init().then(() => {\n                    return super.request(...fargs).then(resolve).catch(err => {\n                        if (typeof err !== 'string' && !(err instanceof Error)) {\n                            if (err.status && err.response && err.error) {\n                                return reject(new Error(err.error.error_summary));\n                            }\n                        }\n                        return reject(err);\n                    });\n                }).catch(reject);\n            });\n        }\n        _createMetadata(root, iter) {\n            return {\n                id: iter.id,\n                filename: iter.name,\n                path: FS.pathJoin(root, iter.path_display),\n                type: iter['.tag'] === 'folder' ? 'dir' : 'file',\n                size: iter.size || 0\n            };\n        }\n        find(file, options, a, mount) {\n            const root = FS.getPathFromVirtual(file.path);\n            return new Promise((resolve, reject) => {\n                this.dbx.filesSearch({\n                    path: root === '/' ? '' : root,\n                    query: options.query,\n                    max_results: MAX_RESULTS,\n                    mode: { '.tag': 'filename' }\n                }).then(response => {\n                    return resolve(response.matches.map(iter => {\n                        return this._createMetadata(mount.option('root'), iter.metadata);\n                    }));\n                }).catch(reject);\n            });\n        }\n        scandir(item, options, mount) {\n            const root = FS.getPathFromVirtual(item.path);\n            let result = [];\n            const scandir = cursor => new Promise((resolve, reject) => {\n                const m = cursor ? 'filesListFolderContinue' : 'filesListFolder';\n                const a = cursor ? { cursor } : { path: root === '/' ? '' : root };\n                this.dbx[m](a).then(response => {\n                    const found = (response.entries || []).map(iter => {\n                        return this._createMetadata(mount.option('root'), iter);\n                    });\n                    result = result.concat(found);\n                    if (response.has_more && response.cursor) {\n                        return scandir(response.cursor).then(resolve).catch(reject);\n                    }\n                    return resolve(result);\n                }).catch(reject);\n            });\n            return scandir(null);\n        }\n        read(item, options, mount) {\n            return new Promise((resolve, reject) => {\n                this.url(item, { dl: 0 }).then(url => {\n                    this.dbx.sharingGetSharedLinkFile({ url }).then(data => {\n                        return resolve(data.fileBlob);\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n        write(file, data) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesUpload({\n                    path: FS.getPathFromVirtual(file.path),\n                    mode: { '.tag': 'overwrite' },\n                    contents: data\n                }).then(() => resolve(true)).catch(reject);\n            });\n        }\n        copy(src, dest) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesCopy({\n                    from_path: FS.getPathFromVirtual(src.path),\n                    to_path: FS.getPathFromVirtual(dest.path)\n                }).then(() => resolve(true)).catch(reject);\n            });\n        }\n        move(src, dest) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesMove({\n                    from_path: FS.getPathFromVirtual(src.path),\n                    to_path: FS.getPathFromVirtual(dest.path)\n                }).then(() => resolve(true)).catch(reject);\n            });\n        }\n        exists(item) {\n            return new Promise((resolve, reject) => {\n                this.fileinfo(item).then(() => resolve(true)).catch(() => resolve(false));\n            });\n        }\n        fileinfo(item) {\n            return this.dbx.filesGetMetadata({ path: FS.getPathFromVirtual(item.path) });\n        }\n        url(item, options) {\n            const visibility = 'public';\n            const hasLink = () => new Promise((resolve, reject) => {\n                this.dbx.sharingGetSharedLinks({ path: FS.getPathFromVirtual(item.path) }).then(response => {\n                    if (response.links.length) {\n                        const found = response.links.find(iter => iter.visibility['.tag'] === visibility);\n                        const dl = typeof options.dl === 'undefined' ? 1 : options.dl;\n                        if (found) {\n                            return resolve(found.url.replace('dl=0', 'dl=' + String(dl)));\n                        }\n                    }\n                    return resolve(false);\n                }).catch(reject);\n            });\n            const newLink = () => new Promise((resolve, reject) => {\n                this.dbx.sharingCreateSharedLinkWithSettings({\n                    path: FS.getPathFromVirtual(item.path),\n                    settings: { requested_visibility: visibility }\n                }).then(response => {\n                    return resolve(response.url);\n                }).catch(reject);\n            });\n            return new Promise((resolve, reject) => {\n                hasLink().then(url => {\n                    if (url) {\n                        console.warn('ALREADY HAS URL', url);\n                        return resolve(url);\n                    }\n                    console.warn('CREATING NEW URL');\n                    return newLink().then(resolve).catch(reject);\n                }).catch(reject);\n            });\n        }\n        mkdir(dir) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesCreateFolder({ path: FS.getPathFromVirtual(dir.path) }).then(() => resolve(true)).catch(reject);\n            });\n        }\n        upload(dest, file) {\n            const item = new FileMetadata({\n                filename: file.name,\n                path: FS.pathJoin(dest.path, file.name),\n                mime: file.type,\n                size: file.size\n            });\n            return this.write(item, file);\n        }\n        freeSpace(root) {\n            return new Promise((resolve, reject) => {\n                this.dbx.usersGetSpaceUsage().then(response => {\n                    try {\n                        if (response.allocation && typeof response.allocation.individual !== 'undefined') {\n                            return resolve(response.allocation.individual.allocated);\n                        }\n                    } catch (e) {\n                        console.warn(e);\n                    }\n                    return resolve(-1);\n                }).catch(reject);\n            });\n        }\n        unlink(src) {\n            return new Promise((resolve, reject) => {\n                this.dbx.filesDelete({ path: FS.getPathFromVirtual(src.path) }).then(() => resolve(true)).catch(reject);\n            });\n        }\n    };\n});"]}