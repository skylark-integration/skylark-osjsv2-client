{"version":3,"sources":["vfs/transports/google-drive.js"],"names":["define","axios","Transport","FileMetadata","FileDataURL","MountManager","a","GoogleAPI","FS","CACHE_CLEAR_TIMEOUT","_authenticated","_clearCacheTimeout","_rootFolderId","_treeCache","gapi","window","createDirectoryList","dir","list","item","options","match","result","isOnRoot","replace","forEach","iter","i","push","path","title","dirname","fileType","mimeType","kind","filename","id","size","quotaBytesUsed","mime","type","createItem","getAllDirectoryFiles","callback","doRetrieve","cb","clearTimeout","console","info","retrievePageOfFiles","request","execute","resp","error","warn","concat","items","nextPageToken","client","drive","files","pageToken","e","stack","retrieveAllFiles","root","idList","parentList","parents","piter","resolves","getPathFromVirtual","split","filter","el","currentParentId","length","_getFileList","foundId","indexOf","_nextDir","completed","found","current","shift","done","getFilesBelongingTo","response","groupEnd","setTimeout","debug","group","about","get","rootFolderId","_","getFileFromPath","tmpItem","ldir","getParentPathId","setFolder","pid","children","insert","folderId","resource","p","delete","childId","[object Object]","Promise","resolve","reject","create","scope","load","err","res","Error","method","args","mount","fargs","arguments","this","_init","then","super","catch","option","read","ritem","fileId","file","accessToken","auth","getToken","access_token","url","downloadUrl","responseType","headers","Authorization","data","message","write","parentId","uri","boundary","delimiter","close_delim","contentType","createBody","metadata","base64Data","JSON","stringify","reqContentType","body","toBase64","abToBinaryString","btoa","createBoundary","fileData","params","uploadType","Content-Type","exists","src","dest","copy","msg","patch","req","scandir","find","k","webContentLink","mkdir","module","getModuleFromPath","name","pathJoin","trash","untrash","emptyTrash","unlink","s"],"mappings":";;;;;;;AAAAA,QACI,gBACA,eACA,UACA,iBACA,2BACA,qBACA,2BACA,kBACD,SAAUC,EAAOC,EAAWC,EAAcC,EAAaC,EAAcC,EAAGC,EAAWC,GAClF,aACA,MAAMC,EAAsB,IAC5B,IACIC,EACAC,EACAC,EACAC,EAJAC,EAAOC,OAAOD,KAAOC,OAAOD,SAKhC,SAASE,EAAoBC,EAAKC,EAAMC,EAAMC,EAASC,GACnD,MAAMC,KAEAC,EAAoB,MADbN,EAAIO,QAAQH,EAAO,KAAKG,QAAQ,OAAQ,KAiCrD,OARIN,GACAA,EAAKO,QAAQ,CAACC,EAAMC,KACXD,GAGLJ,EAAOM,KA5Bf,SAAoBF,EAAMC,GACtB,IAAIE,EAAOZ,EACQ,OAAfS,EAAKI,MACLD,EAAOrB,EAAGuB,QAAQd,IAEbM,IACDM,GAAQ,KAEZA,GAAQH,EAAKI,OAEjB,IAAIE,EAA6B,uCAAlBN,EAAKO,SAAoD,MAAsB,eAAdP,EAAKQ,KAAwB,OAAS,MAItH,MAHsB,sCAAlBR,EAAKO,WACLD,EAAW,SAER,IAAI7B,GACPgC,SAAUT,EAAKI,MACfD,KAAMA,EACNO,GAAIV,EAAKU,GACTC,KAAMX,EAAKY,gBAAkB,EAC7BC,KAAwB,uCAAlBb,EAAKO,SAAoD,KAAOP,EAAKO,SAC3EO,KAAMR,IAQMS,CAAWf,MAGxBJ,MAEX,SAASoB,EAAqBvB,EAAMwB,GAqHhC,SAASC,KAnHT,SAA0BC,GAKtB,GAJIlC,IACAmC,aAAanC,GACbA,EAAqB,MAErBE,EAGA,OAFAkC,QAAQC,KAAK,yCACbH,GAAG,EAAOhC,GAGdkC,QAAQC,KAAK,kBACb,IAAI9B,KAiBJ,KAhBA,SAAS+B,EAAoBC,EAAS5B,GAClC4B,EAAQC,QAAQC,IACRA,EAAKC,OACLN,QAAQO,KAAK,sCAAuC,QAASF,GAEjE9B,EAASA,EAAOiC,OAAOH,EAAKI,OAC5B,MAAMC,EAAgBL,EAAKK,cACvBA,EAEAR,EADAC,EAAUpC,EAAK4C,OAAOC,MAAMC,MAAM1C,MAAO2C,UAAWJ,IACvBnC,IAE7BT,EAAaS,EACbuB,GAAG,EAAOvB,MAMlB2B,CADuBnC,EAAK4C,OAAOC,MAAMC,MAAM1C,SACXA,GACtC,MAAO4C,GACLf,QAAQO,KAAK,gDAAiDQ,EAAGA,EAAEC,OACnEhB,QAAQO,KAAK,4DACbT,GAAG,EAAO3B,IAkFd8C,CAAiB,CAACX,EAAOnC,KACrB,MAAM+C,EAAO9C,EAAKU,KACdwB,EACAV,EAASU,GAAO,EAAOY,GAlFnC,SAA6B/C,EAAM+C,EAAMpB,GACrC,MAAMqB,KACAC,KACNjD,EAAKO,QAAQC,IACT,GAAIA,EAAM,CACNwC,EAAOxC,EAAKU,IAAMV,EAClB,MAAM0C,KACF1C,EAAK0C,SACL1C,EAAK0C,QAAQ3C,QAAQ4C,IACbA,GACAD,EAAQxC,KAAKyC,EAAMjC,MAI/B+B,EAAWzC,EAAKU,IAAMgC,KAG9B,IAAIE,EAAW9D,EAAG+D,mBAAmBN,GAAMzC,QAAQ,OAAQ,IAAIgD,MAAM,KACrEF,EAAWA,EAASG,OAAOC,GACT,KAAPA,GAEX,IAAIC,EAAkB/D,EAClBW,GAAY+C,EAASM,OACzB,SAASC,EAAaC,GAClB,MAAMxD,KAeN,OAdKC,GACDD,EAAOM,MACHE,MAAO,KACPD,KAAMrB,EAAGuB,QAAQkC,GACjB7B,GAAIjB,EAAKiB,GACTE,eAAgB,EAChBL,SAAU,uCAGlBf,EAAKO,QAAQC,IACLA,GAAQyC,EAAWzC,EAAKU,MAAiD,IAA1C+B,EAAWzC,EAAKU,IAAI2C,QAAQD,IAC3DxD,EAAOM,KAAKF,KAGbJ,GAEX,SAAS0D,EAASC,GACd,IAEIC,EAFAC,EAAUb,EAASc,QACnBC,EAAOf,EAASM,QAAU,EAE1BrD,EACA2D,EAAQP,EAEJQ,GACAjE,EAAKO,QAAQC,IACLA,GACIA,EAAKI,QAAUqD,GAAWhB,EAAWzC,EAAKU,MAAyD,IAAlD+B,EAAWzC,EAAKU,IAAI2C,QAAQJ,KAC7EA,EAAkBjD,EAAKU,GACvB8C,EAAQxD,EAAKU,MAM7BiD,EACAJ,EAAUC,GAEVF,EAASC,GAGjBD,CAASF,IACDA,GAAWZ,EAAOY,GAClBjC,GAAG,EAAOgC,EAAaC,IAGnBvD,EACAsB,GAAG,EAAOgC,EAAaF,IAI/B9B,EAAG,8BAUHyC,CAAoBpE,EAAM+C,EAAM,CAACZ,EAAOkC,KACpCxC,QAAQyC,WACR7E,EAAqB8E,WAAW,KAC5B1C,QAAQC,KAAK,wCACbnC,EAAa,MACdJ,GACHsC,QAAQ2C,MAAM,uCAAwC,KAAMH,GAC5D5C,EAASU,EAAOkC,EAAUtB,OAKtC,GAvIAlB,QAAQ2C,MAAM,uCAAwCvE,GAsItD4B,QAAQ4C,MAAM,wCACT/E,EAWDgC,QAXgB,CACA9B,EAAK4C,OAAOC,MAAMiC,MAAMC,MAChC1C,QAAQC,IACPA,GAASA,EAAK0C,cAInBlF,EAAgBwC,EAAK0C,aACrBlD,KAJID,EAASrC,EAAEyF,EAAE,6BAU7B,SAASC,EAAgB/E,EAAKuB,EAAMG,GAC5B1B,aAAed,IACfc,EAAMA,EAAIY,MAEd,MAAMoE,EAAU,IAAI9F,GAChBgC,SAAU3B,EAAG2B,SAASlB,GACtBuB,KAAM,MACNX,KAAMrB,EAAGuB,QAAQd,KAErB8B,QAAQ2C,MAAM,oCAAqCzE,EAAKuB,EAAMyD,GAC9DvD,EAAqBuD,EAAS,CAAC5C,EAAOnC,EAAMgF,KACxC,GAAI7C,EAEA,YADAV,EAASU,GAGb,IAAI6B,EAAQ,KACZhE,EAAKO,QAAQC,IACT,GAAIA,EAAKI,QAAUtB,EAAG2B,SAASlB,GAC3B,GAAIuB,GACA,GAAId,EAAKO,WAAaO,EAElB,OADA0C,EAAQxD,GACD,OAGXwD,EAAQxD,EAGhB,OAAO,IAEXiB,GAAS,EAAOuC,KAGxB,SAASiB,EAAgBhF,EAAMwB,GAC3B,MAAM1B,EAAMT,EAAGuB,QAAQZ,EAAKU,MAE5BkB,QAAQ2C,MAAM,kCAAmCvE,GACjD6E,EAAgB/E,EAFH,qCAEc,CAACoC,EAAOlC,KAC3BkC,EACAV,EAASU,GAETV,GAAS,EAAOxB,EAAOA,EAAKiB,GAAK,QAiC7C,SAASgE,EAAUjF,EAAMkF,EAAK1D,GAG1B,IAAuBE,EAFvBE,QAAQC,KAAK,2BAA4B7B,EAAMkF,GAC/CA,EAAMA,GAAO,OACUxD,EAuBT,MATM/B,EAAK4C,OAAOC,MAAM2C,SAASC,QACvCC,SAAUH,EACVI,UAAYrE,GAAIjB,EAAKiB,MAEjBe,QAAQC,IACZL,QAAQC,KAAK,2BAA4B,KAAMI,GAC/CT,GAAS,GAAO,OAnBpBxB,EAAKiD,QAAQ3C,QAAQ,CAACiF,EAAG/E,KACLb,EAAK4C,OAAOC,MAAM2C,SAASK,QACvCH,SAAUE,EAAEtE,GACZwE,QAASzF,EAAKiB,KAEVe,QAAQC,IACRzB,GAAKR,EAAKiD,QAAQQ,OAAS,GAC3B/B,QAmBpB,qBAA0C3C,EACtC2G,QACI,OAAInG,EACOoG,QAAQC,UAEZ,IAAID,QAAQ,CAACC,EAASC,KACzBzG,EAAU0G,QACNC,OACI,gDACA,6CACA,UAEJC,MACI,iBACA,gBAEL,CAACC,EAAKC,KACLvG,EAAK4C,OAAOyD,KAAK,QAAS,KAAMC,IACvBA,IACD1G,GAAiB,GAEd0G,EAAMJ,EAAO,IAAIM,MAAMF,IAAQL,GAAQ,SAK9DF,QAAQU,EAAQC,EAAMpG,EAASqG,GAC3B,MAAMC,EAAQC,UACd,OAAO,IAAIb,QAAQ,CAACC,EAASC,KACzBY,KAAKC,QAAQC,KAAK,IACPC,MAAM7E,WAAWwE,GAAOI,KAAKf,GAASiB,MAAMhB,IACpDgB,MAAMhB,KAGjBH,QAAQ1F,EAAMC,EAASqG,GACnB,OAAO,IAAIX,QAAQ,CAACC,EAASC,KACzBtE,EAAqBvB,EAAM,CAACkC,EAAOnC,EAAMD,KACrC,GAAIoC,EACA2D,EAAO,IAAIM,MAAMjE,QACd,CACH,MAAM/B,EAASN,EAAoBC,EAAKC,EAAMC,EAAMC,EAASqG,EAAMQ,OAAO,UAC1ElB,EAAQzF,QAKxBuF,KAAK1F,EAAMC,EAASqG,GAChB,MAAMS,EAAOC,GAAS,IAAIrB,QAAQ,CAACC,EAASC,KACxBlG,EAAK4C,OAAOC,MAAMC,MAAMiC,KAAMuC,OAAQD,EAAM/F,KACpDe,QAAQkF,IACZ,GAAIA,GAAQA,EAAKjG,GAAI,CACjB,IAAIkG,EAAcxH,EAAKyH,KAAKC,WAAWC,aACvCxI,GACIyI,IAAKL,EAAKM,YACVpB,OAAQ,MACRqB,aAAc,cACdC,SAAWC,cAAiB,UAAYR,KACzCR,KAAKvC,GACGwB,EAAQxB,EAASwD,OACzBf,MAAM3E,IACL2D,EAAO,IAAIM,MAAMhH,EAAEyF,EAAE,2BAA6B,MAAQ1C,EAAM2F,iBAGpEhC,EAAO,IAAIM,MAAMhH,EAAEyF,EAAE,8BAIjC,OAAO,IAAIe,QAAQ,CAACC,EAASC,KACrB7F,EAAKwH,YACLT,EAAK/G,GAAM2G,KAAKf,GAASiB,MAAMhB,GAE/BhB,EAAgB7E,EAAKU,KAAMV,EAAKoB,KAAM,SAAUc,EAAOkC,GAC/ClC,EACA2D,EAAO,IAAIM,MAAMjE,IACTkC,EAGR2C,EAAK3C,GAAUuC,KAAKf,GAASiB,MAAMhB,GAFnCA,EAAO,IAAIM,MAAMhH,EAAEyF,EAAE,8BAQzCc,MAAMwB,EAAMU,GACR,MAAME,EAAQ,CAACC,EAAUd,IAAW,IAAItB,QAAQ,CAACC,EAASC,KACtD,IAAImC,EAAM,yBACN5B,EAAS,OACTa,IACAe,EAAM,0BAA4Bf,EAClCb,EAAS,OApJzB,SAAwBc,EAAMU,EAAMpG,GAChC,MAAMyG,EAAW,+BACXC,EAAY,SAAWD,EAAW,OAClCE,EAAc,SAAWF,EAAW,KACpCG,EAAclB,EAAK9F,MAAQ,aACjC,SAASiH,EAAWlI,GAChB,MAAMmI,GACF3H,MAAOuG,EAAKlG,SACZF,SAAUsH,GAERG,EAAapI,EAEnB,OAD6B+H,EAAY,yCAA2CM,KAAKC,UAAUH,GAAYJ,EAAY,iBAAmBE,EAAc,gDAA4DG,EAAaJ,EAGzO,MAAMO,EAAiB,8BAAgCT,EAAW,IAC9DL,aAAgB3I,EAChBuC,GAAS,GACL4G,YAAaM,EACbC,KAAMN,EAAWT,EAAKgB,cAG1BvJ,EAAGwJ,iBAAiBjB,EAAMQ,EAAa,CAAClG,EAAOkC,KAC3C5C,EAASU,GAAOA,IACZkG,YAAaM,EACbC,KAAMN,EAAWS,KAAK1E,QA8H1B2E,CAAe7B,EAAMU,EAAM,CAAC1F,EAAO8G,KAC/B,GAAI9G,EACA2D,EAAO,IAAIM,MAAMjE,QACd,CACavC,EAAK4C,OAAOR,SACxBrB,KAAMsH,EACN5B,OAAQA,EACR6C,QAAUC,WAAY,aACtBxB,SAAWyB,eAAgBH,EAASZ,aACpCO,KAAMK,EAASL,OAEX3G,QAAQC,IACZvC,EAAa,KACTuC,GAAQA,EAAKhB,GACT8G,EACA9C,EAAUhD,EAAM8F,EAAU,CAAC9B,EAAKC,IACrBD,EAAMJ,EAAO,IAAIM,MAAMF,IAAQL,EAAQM,IAGlDN,GAAQ,GAGZC,EAAO1G,EAAEyF,EAAE,gCAM/B,OAAO,IAAIe,QAAQ,CAACC,EAASC,KACzBb,EAAgBkC,EAAM,CAAChF,EAAOjB,KACtBiB,EACA2D,EAAO,IAAIM,MAAMjE,IACVgF,EAAKjG,GACZ6G,EAAM7G,EAAIiG,EAAKjG,IAAI0F,KAAKf,GAASiB,MAAMhB,GAEvCY,KAAK2C,OAAOlC,GAAMP,KAAKyC,GACZtB,EAAM7G,EAAImI,EAASA,EAAOnI,GAAK,MAAM0F,KAAKf,GAASiB,MAAMhB,IACjEgB,MAAM,KACLiB,EAAM7G,EAAI,MAAM0F,KAAKf,GAASiB,MAAMhB,SAMxDH,KAAK2D,EAAKC,GACN,OAAO,IAAI3D,QAAQ,CAACC,EAASC,KACTlG,EAAK4C,OAAOC,MAAMC,MAAM8G,MACpCtC,OAAQoC,EAAIpI,GACZqE,UAAY3E,MAAOtB,EAAG2B,SAASsI,EAAK5I,SAEhCsB,QAAQC,IACZ,GAAIA,EAAKhB,GACL+D,EAAgBsE,EAAM,CAACpH,EAAO6F,KACtB7F,GACAN,QAAQO,KAAKD,GACb0D,GAAQ,KAERlG,EAAa,KACbuF,EAAUhD,EAAM8F,EAAU,CAAC9B,EAAKC,IACrBD,EAAMJ,EAAO,IAAIM,MAAMF,IAAQL,EAAQM,WAIvD,CACH,MAAMsD,EAAMvH,GAAQA,EAAK4F,QAAU5F,EAAK4F,QAAU1I,EAAEyF,EAAE,yBACtDiB,EAAO,IAAIM,MAAMqD,SAKjC9D,KAAK2D,EAAKC,GACN,OAAO,IAAI3D,QAAQ,CAACC,EAASC,KACTlG,EAAK4C,OAAOC,MAAMC,MAAMgH,OACpCxC,OAAQoC,EAAIpI,GACZqE,UAAY3E,MAAOtB,EAAG2B,SAASsI,EAAK5I,SAEhCsB,QAAQC,IACZ,GAAIA,GAAQA,EAAKhB,GACbvB,EAAa,KACbkG,GAAQ,OACL,CACH,MAAM4D,EAAMvH,GAAQA,EAAK4F,QAAU5F,EAAK4F,QAAU1I,EAAEyF,EAAE,yBACtDiB,EAAO,IAAIM,MAAMqD,SAKjC9D,OAAO1F,GACH,OAAO,IAAI2F,QAAQ,CAACC,EAASC,KACzB,MAAM6D,EAAM,IAAI1K,EAAaK,EAAGuB,QAAQZ,EAAKU,OAC7C+F,KAAKkD,QAAQD,GAAK/C,KAAKxG,IACnB,MAAM4D,EAAQ5D,EAAOyJ,KAAKrJ,GAAQA,EAAKG,OAASV,EAAKU,MACrD,GAAIqD,EAAO,CACP,MAAMmD,EAAO,IAAIlI,EAAagB,EAAKU,KAAMqD,EAAMjD,UAG/C,OAFAoG,EAAKjG,GAAK8C,EAAM9C,GAChBiG,EAAKvG,MAAQoD,EAAMpD,MACZiF,EAAQsB,GAEnB,OAAOtB,GAAQ,KAChBiB,MAAMhB,KAGjBH,SAAS1F,GACL,OAAO,IAAI2F,QAAQ,CAACC,EAASC,KACTlG,EAAK4C,OAAOC,MAAMC,MAAMiC,KAAMuC,OAAQjH,EAAKiB,KACnDe,QAAQC,IACZ,GAAIA,GAAQA,EAAKhB,GAAI,CACjB,MAYMY,MAXF,cACA,KACA,oBACA,qBACA,uBACA,WACA,mBACA,eACA,QACA,iBAGIvB,QAAQuJ,IACZhI,EAAKgI,GAAK5H,EAAK4H,KAEnBjE,EAAQ/D,QAERgE,EAAO1G,EAAEyF,EAAE,6BAK3Bc,IAAI1F,GACA,OAAO,IAAI2F,QAAQ,CAACC,EAASC,KACzB,GAAK7F,GAASA,EAAKiB,GAEZ,CACatB,EAAK4C,OAAOC,MAAMC,MAAMiC,KAAMuC,OAAQjH,EAAKiB,KACnDe,QAAQC,IACZ,GAAIA,GAAQA,EAAK6H,eACblE,EAAQ3D,EAAK6H,oBACV,CACH,MAAMN,EAAMvH,GAAQA,EAAK4F,QAAU5F,EAAK4F,QAAU1I,EAAEyF,EAAE,yBACtDiB,EAAO,IAAIM,MAAMqD,YARzB3D,EAAO,IAAIM,MAAM,uCAc7BT,MAAM5F,GACF,MAAMiK,EAAQ9G,GAAW,IAAI0C,QAAQ,CAACC,EAASC,KAC3BlG,EAAK4C,OAAOR,SACxBrB,KAAQ,kBACR0F,OAAU,OACVuC,KAAQH,KAAKC,WACT9H,MAAOb,EAAIkB,SACXiC,QAASA,EACTnC,SAAU,yCAGVkB,QAAQC,IACZ,GAAIA,GAAQA,EAAKhB,GACbvB,EAAa,KACbkG,GAAQ,OACL,CACH,MAAM4D,EAAMvH,GAAQA,EAAK4F,QAAU5F,EAAK4F,QAAU1I,EAAEyF,EAAE,yBACtDiB,EAAO,IAAIM,MAAMqD,SAI7B,OAAO,IAAI7D,QAAQ,CAACC,EAASC,KACzB,MAAMmE,OAAS9K,EAAa+K,kBAAkBnK,EAAIY,MAClCrB,EAAG+D,mBAAmB/D,EAAGuB,QAAQd,EAAIY,SACpCrB,EAAG+D,mBAAmB4G,OAAOlD,OAAO,SAEjD9B,EAAgBlF,EAAK,CAACoC,EAAOjB,KACrBiB,IAAUjB,EACV4E,EAAO,IAAIM,MAAMhH,EAAEyF,EAAE,2BAA4B1C,GAAS/C,EAAEyF,EAAE,2BAE9DmF,IAAS9I,GAAIA,KAAO0F,KAAKf,GAASiB,MAAMhB,KAIhDkE,EAAM,MAAMpD,KAAKf,GAASiB,MAAMhB,KAI5CH,OAAO4D,EAAMpC,GACT,MAAMlH,EAAO,IAAIhB,GACbgC,SAAUkG,EAAKgD,KACfxJ,KAAMrB,EAAG8K,SAASb,EAAK5I,KAAMwG,EAAKgD,MAClC9I,KAAM8F,EAAK7F,KACXH,KAAMgG,EAAKhG,OAEf,OAAOuF,KAAKqB,MAAM9H,EAAMkH,GAE5BxB,MAAMwB,GACF,OAAO,IAAIvB,QAAQ,CAACC,EAASC,KACTlG,EAAK4C,OAAOC,MAAMC,MAAM2H,OAAQnD,OAAQC,EAAKjG,KACrDe,QAAQC,IACZ,GAAIA,EAAKhB,GACL2E,GAAQ,OACL,CACH,MAAM4D,EAAMvH,GAAQA,EAAK4F,QAAU5F,EAAK4F,QAAU1I,EAAEyF,EAAE,yBACtDiB,EAAO,IAAIM,MAAMqD,SAKjC9D,QAAQwB,GACJ,OAAO,IAAIvB,QAAQ,CAACC,EAASC,KACTlG,EAAK4C,OAAOC,MAAMC,MAAM4H,SAAUpD,OAAQC,EAAKjG,KACvDe,QAAQC,IACZ,GAAIA,EAAKhB,GACL2E,GAAQ,OACL,CACH,MAAM4D,EAAMvH,GAAQA,EAAK4F,QAAU5F,EAAK4F,QAAU1I,EAAEyF,EAAE,yBACtDiB,EAAO,IAAIM,MAAMqD,SAKjC9D,aACI,OAAO,IAAIC,QAAQ,CAACC,EAASC,KACTlG,EAAK4C,OAAOC,MAAMC,MAAM6H,eAChCtI,QAAQC,IACZ,GAAIA,GAAQA,EAAK4F,QAAS,CACtB,MAAM2B,EAAMvH,GAAQA,EAAK4F,QAAU5F,EAAK4F,QAAU1I,EAAEyF,EAAE,yBACtDiB,EAAO,IAAIM,MAAMqD,SAEjB5D,GAAQ,OAKxBF,UAAU5C,GACN,OAAO6C,QAAQC,SAAS,GAE5BF,OAAO2D,GACH,MAAMkB,EAASC,IACX9K,EAAa,KACN,IAAIiG,QAAQ,CAACC,EAASC,KACTlG,EAAK4C,OAAOC,MAAMC,MAAM+C,QAASyB,OAAQuD,EAAEvJ,KACnDe,QAAQC,IACZ,GAAIA,GAA+B,iBAAhBA,EAAK9B,OACpByF,GAAQ,OACL,CACH,MAAM4D,EAAMvH,GAAQA,EAAK4F,QAAU5F,EAAK4F,QAAU1I,EAAEyF,EAAE,yBACtDiB,EAAO,IAAIM,MAAMqD,UAKjC,OAAKH,EAAIpI,GAaFsJ,EAAOlB,GAZH,IAAI1D,QAAQ,CAACC,EAASC,KACzBhB,EAAgBwE,EAAI3I,KAAM2I,EAAIjI,KAAM,CAACc,EAAOkC,KACpClC,EACA2D,EAAO,IAAIM,MAAMjE,IACTkC,EAGRmG,EAAOnG,GAAUuC,KAAKf,GAASiB,MAAMhB,GAFrCA,EAAO,IAAIM,MAAMhH,EAAEyF,EAAE","file":"../../../vfs/transports/google-drive.js","sourcesContent":["define([\n    'skylark-axios',\n    '../transport',\n    '../file',\n    '../filedataurl',\n    '../../core/mount-manager',\n    '../../core/locales',\n    '../../helpers/google-api',\n    '../../utils/fs'\n], function (axios, Transport, FileMetadata, FileDataURL, MountManager, a, GoogleAPI, FS) {\n    'use strict';\n    const CACHE_CLEAR_TIMEOUT = 7000;\n    let gapi = window.gapi = window.gapi || {};\n    let _authenticated;\n    let _clearCacheTimeout;\n    let _rootFolderId;\n    let _treeCache;\n    function createDirectoryList(dir, list, item, options, match) {\n        const result = [];\n        const rdir = dir.replace(match, '/').replace(/\\/+/g, '/');\n        const isOnRoot = rdir === '/';\n        function createItem(iter, i) {\n            let path = dir;\n            if (iter.title === '..') {\n                path = FS.dirname(dir);\n            } else {\n                if (!isOnRoot) {\n                    path += '/';\n                }\n                path += iter.title;\n            }\n            let fileType = iter.mimeType === 'application/vnd.google-apps.folder' ? 'dir' : iter.kind === 'drive#file' ? 'file' : 'dir';\n            if (iter.mimeType === 'application/vnd.google-apps.trash') {\n                fileType = 'trash';\n            }\n            return new FileMetadata({\n                filename: iter.title,\n                path: path,\n                id: iter.id,\n                size: iter.quotaBytesUsed || 0,\n                mime: iter.mimeType === 'application/vnd.google-apps.folder' ? null : iter.mimeType,\n                type: fileType\n            });\n        }\n        if (list) {\n            list.forEach((iter, i) => {\n                if (!iter) {\n                    return;\n                }\n                result.push(createItem(iter, i));\n            });\n        }\n        return result ? result : [];\n    }\n    function getAllDirectoryFiles(item, callback) {\n        console.debug('GoogleDrive::*getAllDirectoryFiles()', item);\n        function retrieveAllFiles(cb) {\n            if (_clearCacheTimeout) {\n                clearTimeout(_clearCacheTimeout);\n                _clearCacheTimeout = null;\n            }\n            if (_treeCache) {\n                console.info('USING CACHE FROM PREVIOUS FETCH!');\n                cb(false, _treeCache);\n                return;\n            }\n            console.info('UPDATING CACHE');\n            let list = [];\n            function retrievePageOfFiles(request, result) {\n                request.execute(resp => {\n                    if (resp.error) {\n                        console.warn('GoogleDrive::getAllDirectoryFiles()', 'error', resp);\n                    }\n                    result = result.concat(resp.items);\n                    const nextPageToken = resp.nextPageToken;\n                    if (nextPageToken) {\n                        request = gapi.client.drive.files.list({ pageToken: nextPageToken });\n                        retrievePageOfFiles(request, result);\n                    } else {\n                        _treeCache = result;\n                        cb(false, result);\n                    }\n                });\n            }\n            try {\n                const initialRequest = gapi.client.drive.files.list({});\n                retrievePageOfFiles(initialRequest, list);\n            } catch (e) {\n                console.warn('GoogleDrive::getAllDirectoryFiles() exception', e, e.stack);\n                console.warn('THIS ERROR OCCURS WHEN MULTIPLE REQUESTS FIRE AT ONCE ?!');\n                cb(false, list);\n            }\n        }\n        function getFilesBelongingTo(list, root, cb) {\n            const idList = {};\n            const parentList = {};\n            list.forEach(iter => {\n                if (iter) {\n                    idList[iter.id] = iter;\n                    const parents = [];\n                    if (iter.parents) {\n                        iter.parents.forEach(piter => {\n                            if (piter) {\n                                parents.push(piter.id);\n                            }\n                        });\n                    }\n                    parentList[iter.id] = parents;\n                }\n            });\n            let resolves = FS.getPathFromVirtual(root).replace(/^\\/+/, '').split('/');\n            resolves = resolves.filter(el => {\n                return el !== '';\n            });\n            let currentParentId = _rootFolderId;\n            let isOnRoot = !resolves.length;\n            function _getFileList(foundId) {\n                const result = [];\n                if (!isOnRoot) {\n                    result.push({\n                        title: '..',\n                        path: FS.dirname(root),\n                        id: item.id,\n                        quotaBytesUsed: 0,\n                        mimeType: 'application/vnd.google-apps.folder'\n                    });\n                }\n                list.forEach(iter => {\n                    if (iter && parentList[iter.id] && parentList[iter.id].indexOf(foundId) !== -1) {\n                        result.push(iter);\n                    }\n                });\n                return result;\n            }\n            function _nextDir(completed) {\n                let current = resolves.shift();\n                let done = resolves.length <= 0;\n                let found;\n                if (isOnRoot) {\n                    found = currentParentId;\n                } else {\n                    if (current) {\n                        list.forEach(iter => {\n                            if (iter) {\n                                if (iter.title === current && parentList[iter.id] && parentList[iter.id].indexOf(currentParentId) !== -1) {\n                                    currentParentId = iter.id;\n                                    found = iter.id;\n                                }\n                            }\n                        });\n                    }\n                }\n                if (done) {\n                    completed(found);\n                } else {\n                    _nextDir(completed);\n                }\n            }\n            _nextDir(foundId => {\n                if (foundId && idList[foundId]) {\n                    cb(false, _getFileList(foundId));\n                    return;\n                } else {\n                    if (isOnRoot) {\n                        cb(false, _getFileList(currentParentId));\n                        return;\n                    }\n                }\n                cb('Could not list directory');\n            });\n        }\n        function doRetrieve() {\n            retrieveAllFiles((error, list) => {\n                const root = item.path;\n                if (error) {\n                    callback(error, false, root);\n                    return;\n                }\n                getFilesBelongingTo(list, root, (error, response) => {\n                    console.groupEnd();\n                    _clearCacheTimeout = setTimeout(() => {\n                        console.info('Clearing GoogleDrive filetree cache!');\n                        _treeCache = null;\n                    }, CACHE_CLEAR_TIMEOUT);\n                    console.debug('GoogleDrive::*getAllDirectoryFiles()', '=>', response);\n                    callback(error, response, root);\n                });\n            });\n        }\n        console.group('GoogleDrive::*getAllDirectoryFiles()');\n        if (!_rootFolderId) {\n            const request = gapi.client.drive.about.get();\n            request.execute(resp => {\n                if (!resp || !resp.rootFolderId) {\n                    callback(a._('ERR_VFSMODULE_ROOT_ID'));\n                    return;\n                }\n                _rootFolderId = resp.rootFolderId;\n                doRetrieve();\n            });\n        } else {\n            doRetrieve();\n        }\n    }\n    function getFileFromPath(dir, type, callback) {\n        if (dir instanceof FileMetadata) {\n            dir = dir.path;\n        }\n        const tmpItem = new FileMetadata({\n            filename: FS.filename(dir),\n            type: 'dir',\n            path: FS.dirname(dir)\n        });\n        console.debug('GoogleDrive::*getFileIdFromPath()', dir, type, tmpItem);\n        getAllDirectoryFiles(tmpItem, (error, list, ldir) => {\n            if (error) {\n                callback(error);\n                return;\n            }\n            let found = null;\n            list.forEach(iter => {\n                if (iter.title === FS.filename(dir)) {\n                    if (type) {\n                        if (iter.mimeType === type) {\n                            found = iter;\n                            return false;\n                        }\n                    } else {\n                        found = iter;\n                    }\n                }\n                return true;\n            });\n            callback(false, found);\n        });\n    }\n    function getParentPathId(item, callback) {\n        const dir = FS.dirname(item.path);\n        const type = 'application/vnd.google-apps.folder';\n        console.debug('GoogleDrive::*getParentPathId()', item);\n        getFileFromPath(dir, type, (error, item) => {\n            if (error) {\n                callback(error);\n            } else {\n                callback(false, item ? item.id : null);\n            }\n        });\n    }\n    function createBoundary(file, data, callback) {\n        const boundary = '-------314159265358979323846';\n        const delimiter = '\\r\\n--' + boundary + '\\r\\n';\n        const close_delim = '\\r\\n--' + boundary + '--';\n        const contentType = file.mime || 'text/plain';\n        function createBody(result) {\n            const metadata = {\n                title: file.filename,\n                mimeType: contentType\n            };\n            const base64Data = result;\n            const multipartRequestBody = delimiter + 'Content-Type: application/json\\r\\n\\r\\n' + JSON.stringify(metadata) + delimiter + 'Content-Type: ' + contentType + '\\r\\n' + 'Content-Transfer-Encoding: base64\\r\\n' + '\\r\\n' + base64Data + close_delim;\n            return multipartRequestBody;\n        }\n        const reqContentType = \"multipart/mixed; boundary='\" + boundary + \"'\";\n        if (data instanceof FileDataURL) {\n            callback(false, {\n                contentType: reqContentType,\n                body: createBody(data.toBase64())\n            });\n        } else {\n            FS.abToBinaryString(data, contentType, (error, response) => {\n                callback(error, error ? false : {\n                    contentType: reqContentType,\n                    body: createBody(btoa(response))\n                });\n            });\n        }\n    }\n    function setFolder(item, pid, callback) {\n        console.info('GoogleDrive::setFolder()', item, pid);\n        pid = pid || 'root';\n        function _clearFolders(cb) {\n            item.parents.forEach((p, i) => {\n                const request = gapi.client.drive.children.delete({\n                    folderId: p.id,\n                    childId: item.id\n                });\n                request.execute(resp => {\n                    if (i >= item.parents.length - 1) {\n                        cb();\n                    }\n                });\n            });\n        }\n        function _setFolder(rootId, cb) {\n            const request = gapi.client.drive.children.insert({\n                folderId: pid,\n                resource: { id: item.id }\n            });\n            request.execute(resp => {\n                console.info('GoogleDrive::setFolder()', '=>', resp);\n                callback(false, true);\n            });\n        }\n        _clearFolders(() => {\n            _setFolder(pid, callback);\n        });\n    }\n    return class GoogleDriveTransport extends Transport {\n        _init() {\n            if (_authenticated) {\n                return Promise.resolve();\n            }\n            return new Promise((resolve, reject) => {\n                GoogleAPI.create({\n                    scope: [\n                        'https://www.googleapis.com/auth/drive.install',\n                        'https://www.googleapis.com/auth/drive.file',\n                        'openid'\n                    ],\n                    load: [\n                        'drive-realtime',\n                        'drive-share'\n                    ]\n                }, (err, res) => {\n                    gapi.client.load('drive', 'v2', err => {\n                        if (!err) {\n                            _authenticated = true;\n                        }\n                        return err ? reject(new Error(err)) : resolve(true);\n                    });\n                });\n            });\n        }\n        request(method, args, options, mount) {\n            const fargs = arguments;\n            return new Promise((resolve, reject) => {\n                this._init().then(() => {\n                    return super.request(...fargs).then(resolve).catch(reject);\n                }).catch(reject);\n            });\n        }\n        scandir(item, options, mount) {\n            return new Promise((resolve, reject) => {\n                getAllDirectoryFiles(item, (error, list, dir) => {\n                    if (error) {\n                        reject(new Error(error));\n                    } else {\n                        const result = createDirectoryList(dir, list, item, options, mount.option('match'));\n                        resolve(result);\n                    }\n                });\n            });\n        }\n        read(item, options, mount) {\n            const read = ritem => new Promise((resolve, reject) => {\n                const request = gapi.client.drive.files.get({ fileId: ritem.id });\n                request.execute(file => {\n                    if (file && file.id) {\n                        let accessToken = gapi.auth.getToken().access_token;\n                        axios({\n                            url: file.downloadUrl,\n                            method: 'GET',\n                            responseType: 'arraybuffer',\n                            headers: { 'Authorization': 'Bearer ' + accessToken }\n                        }).then(response => {\n                            return resolve(response.data);\n                        }).catch(error => {\n                            reject(new Error(a._('ERR_VFSMODULE_XHR_ERROR') + ' - ' + error.message));\n                        });\n                    } else {\n                        reject(new Error(a._('ERR_VFSMODULE_NOSUCH')));\n                    }\n                });\n            });\n            return new Promise((resolve, reject) => {\n                if (item.downloadUrl) {\n                    read(item).then(resolve).catch(reject);\n                } else {\n                    getFileFromPath(item.path, item.mime, function (error, response) {\n                        if (error) {\n                            reject(new Error(error));\n                        } else if (!response) {\n                            reject(new Error(a._('ERR_VFSMODULE_NOSUCH')));\n                        } else {\n                            read(response).then(resolve).catch(reject);\n                        }\n                    });\n                }\n            });\n        }\n        write(file, data) {\n            const write = (parentId, fileId) => new Promise((resolve, reject) => {\n                let uri = '/upload/drive/v2/files';\n                let method = 'POST';\n                if (fileId) {\n                    uri = '/upload/drive/v2/files/' + fileId;\n                    method = 'PUT';\n                }\n                createBoundary(file, data, (error, fileData) => {\n                    if (error) {\n                        reject(new Error(error));\n                    } else {\n                        const request = gapi.client.request({\n                            path: uri,\n                            method: method,\n                            params: { uploadType: 'multipart' },\n                            headers: { 'Content-Type': fileData.contentType },\n                            body: fileData.body\n                        });\n                        request.execute(resp => {\n                            _treeCache = null;\n                            if (resp && resp.id) {\n                                if (parentId) {\n                                    setFolder(resp, parentId, (err, res) => {\n                                        return err ? reject(new Error(err)) : resolve(res);\n                                    });\n                                } else {\n                                    resolve(true);\n                                }\n                            } else {\n                                reject(a._('ERR_VFSMODULE_NOSUCH'));\n                            }\n                        });\n                    }\n                });\n            });\n            return new Promise((resolve, reject) => {\n                getParentPathId(file, (error, id) => {\n                    if (error) {\n                        reject(new Error(error));\n                    } else if (file.id) {\n                        write(id, file.id).then(resolve).catch(reject);\n                    } else {\n                        this.exists(file).then(exists => {\n                            return write(id, exists ? exists.id : null).then(resolve).catch(reject);\n                        }).catch(() => {\n                            write(id, null).then(resolve).catch(reject);\n                        });\n                    }\n                });\n            });\n        }\n        copy(src, dest) {\n            return new Promise((resolve, reject) => {\n                const request = gapi.client.drive.files.copy({\n                    fileId: src.id,\n                    resource: { title: FS.filename(dest.path) }\n                });\n                request.execute(resp => {\n                    if (resp.id) {\n                        getParentPathId(dest, (error, parentId) => {\n                            if (error) {\n                                console.warn(error);\n                                resolve(true);\n                            } else {\n                                _treeCache = null;\n                                setFolder(resp, parentId, (err, res) => {\n                                    return err ? reject(new Error(err)) : resolve(res);\n                                });\n                            }\n                        });\n                    } else {\n                        const msg = resp && resp.message ? resp.message : a._('ERR_APP_UNKNOWN_ERROR');\n                        reject(new Error(msg));\n                    }\n                });\n            });\n        }\n        move(src, dest) {\n            return new Promise((resolve, reject) => {\n                const request = gapi.client.drive.files.patch({\n                    fileId: src.id,\n                    resource: { title: FS.filename(dest.path) }\n                });\n                request.execute(resp => {\n                    if (resp && resp.id) {\n                        _treeCache = null;\n                        resolve(true);\n                    } else {\n                        const msg = resp && resp.message ? resp.message : a._('ERR_APP_UNKNOWN_ERROR');\n                        reject(new Error(msg));\n                    }\n                });\n            });\n        }\n        exists(item) {\n            return new Promise((resolve, reject) => {\n                const req = new FileMetadata(FS.dirname(item.path));\n                this.scandir(req).then(result => {\n                    const found = result.find(iter => iter.path === item.path);\n                    if (found) {\n                        const file = new FileMetadata(item.path, found.mimeType);\n                        file.id = found.id;\n                        file.title = found.title;\n                        return resolve(file);\n                    }\n                    return resolve(false);\n                }).catch(reject);\n            });\n        }\n        fileinfo(item) {\n            return new Promise((resolve, reject) => {\n                const request = gapi.client.drive.files.get({ fileId: item.id });\n                request.execute(resp => {\n                    if (resp && resp.id) {\n                        const useKeys = [\n                            'createdDate',\n                            'id',\n                            'lastModifyingUser',\n                            'lastViewedByMeDate',\n                            'markedViewedByMeDate',\n                            'mimeType',\n                            'modifiedByMeDate',\n                            'modifiedDate',\n                            'title',\n                            'alternateLink'\n                        ];\n                        const info = {};\n                        useKeys.forEach(k => {\n                            info[k] = resp[k];\n                        });\n                        resolve(info);\n                    } else {\n                        reject(a._('ERR_VFSMODULE_NOSUCH'));\n                    }\n                });\n            });\n        }\n        url(item) {\n            return new Promise((resolve, reject) => {\n                if (!item || !item.id) {\n                    reject(new Error('url() expects a File ref with Id'));\n                } else {\n                    const request = gapi.client.drive.files.get({ fileId: item.id });\n                    request.execute(resp => {\n                        if (resp && resp.webContentLink) {\n                            resolve(resp.webContentLink);\n                        } else {\n                            const msg = resp && resp.message ? resp.message : a._('ERR_APP_UNKNOWN_ERROR');\n                            reject(new Error(msg));\n                        }\n                    });\n                }\n            });\n        }\n        mkdir(dir) {\n            const mkdir = parents => new Promise((resolve, reject) => {\n                const request = gapi.client.request({\n                    'path': '/drive/v2/files',\n                    'method': 'POST',\n                    'body': JSON.stringify({\n                        title: dir.filename,\n                        parents: parents,\n                        mimeType: 'application/vnd.google-apps.folder'\n                    })\n                });\n                request.execute(resp => {\n                    if (resp && resp.id) {\n                        _treeCache = null;\n                        resolve(true);\n                    } else {\n                        const msg = resp && resp.message ? resp.message : a._('ERR_APP_UNKNOWN_ERROR');\n                        reject(new Error(msg));\n                    }\n                });\n            });\n            return new Promise((resolve, reject) => {\n                const module = MountManager.getModuleFromPath(dir.path);\n                const dirDest = FS.getPathFromVirtual(FS.dirname(dir.path));\n                const rootDest = FS.getPathFromVirtual(module.option('root'));\n                if (dirDest !== rootDest) {\n                    getParentPathId(dir, (error, id) => {\n                        if (error || !id) {\n                            reject(new Error(a._('ERR_VFSMODULE_PARENT_FMT', error || a._('ERR_VFSMODULE_PARENT'))));\n                        } else {\n                            mkdir([{ id: id }]).then(resolve).catch(reject);\n                        }\n                    });\n                } else {\n                    mkdir(null).then(resolve).catch(reject);\n                }\n            });\n        }\n        upload(dest, file) {\n            const item = new FileMetadata({\n                filename: file.name,\n                path: FS.pathJoin(dest.path, file.name),\n                mime: file.type,\n                size: file.size\n            });\n            return this.write(item, file);\n        }\n        trash(file) {\n            return new Promise((resolve, reject) => {\n                const request = gapi.client.drive.files.trash({ fileId: file.id });\n                request.execute(resp => {\n                    if (resp.id) {\n                        resolve(true);\n                    } else {\n                        const msg = resp && resp.message ? resp.message : a._('ERR_APP_UNKNOWN_ERROR');\n                        reject(new Error(msg));\n                    }\n                });\n            });\n        }\n        untrash(file) {\n            return new Promise((resolve, reject) => {\n                const request = gapi.client.drive.files.untrash({ fileId: file.id });\n                request.execute(resp => {\n                    if (resp.id) {\n                        resolve(true);\n                    } else {\n                        const msg = resp && resp.message ? resp.message : a._('ERR_APP_UNKNOWN_ERROR');\n                        reject(new Error(msg));\n                    }\n                });\n            });\n        }\n        emptyTrash() {\n            return new Promise((resolve, reject) => {\n                const request = gapi.client.drive.files.emptyTrash({});\n                request.execute(resp => {\n                    if (resp && resp.message) {\n                        const msg = resp && resp.message ? resp.message : a._('ERR_APP_UNKNOWN_ERROR');\n                        reject(new Error(msg));\n                    } else {\n                        resolve(true);\n                    }\n                });\n            });\n        }\n        freeSpace(root) {\n            return Promise.resolve(-1);\n        }\n        unlink(src) {\n            const unlink = s => {\n                _treeCache = null;\n                return new Promise((resolve, reject) => {\n                    const request = gapi.client.drive.files.delete({ fileId: s.id });\n                    request.execute(resp => {\n                        if (resp && typeof resp.result === 'object') {\n                            resolve(true);\n                        } else {\n                            const msg = resp && resp.message ? resp.message : a._('ERR_APP_UNKNOWN_ERROR');\n                            reject(new Error(msg));\n                        }\n                    });\n                });\n            };\n            if (!src.id) {\n                return new Promise((resolve, reject) => {\n                    getFileFromPath(src.path, src.mime, (error, response) => {\n                        if (error) {\n                            reject(new Error(error));\n                        } else if (!response) {\n                            reject(new Error(a._('ERR_VFSMODULE_NOSUCH')));\n                        } else {\n                            unlink(response).then(resolve).catch(reject);\n                        }\n                    });\n                });\n            }\n            return unlink(src);\n        }\n    };\n});"]}