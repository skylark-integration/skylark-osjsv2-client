{"version":3,"sources":["vfs/transports/osjs.js"],"names":["define","FileMetadata","FS","Connection","Transport","Config","Locales","[object Object]","method","args","options","request","dest","file","path","size","maxSize","getConfig","msg","_","humanFileSize","Promise","reject","Error","fd","FormData","append","filename","Object","keys","forEach","key","String","window","ArrayBuffer","byteLength","addFormFile","meta","this","_request","item","shortcuts","resolve","then","result","map","i","catch","data","overwrite","onprogress","parentfile","dirname","mime","_requestUpload","src","dir","instance","getVFSPath","root"],"mappings":"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","file":"../../../vfs/transports/osjs.js","sourcesContent":["define([\n    '../file',\n    '../../utils/fs',\n    '../../core/connection',\n    '../transport',\n    '../../core/config',\n    '../../core/locales'\n], function (FileMetadata, FS, Connection, Transport, Config, Locales) {\n    'use strict';\n    return class OSjsTransport extends Transport {\n        _request(method, args, options) {\n            return Connection.request('FS:' + method, args, options);\n        }\n        _requestUpload(dest, file, options) {\n            options = options || {};\n            dest = dest instanceof FileMetadata ? dest.path : dest;\n            if (typeof file.size !== 'undefined') {\n                const maxSize = Config.getConfig('VFS.MaxUploadSize');\n                if (maxSize > 0) {\n                    const bytes = file.size;\n                    if (bytes > maxSize) {\n                        const msg = Locales._('DIALOG_UPLOAD_TOO_BIG_FMT', FS.humanFileSize(maxSize));\n                        return Promise.reject(new Error(msg));\n                    }\n                }\n            }\n            const fd = new FormData();\n            fd.append('path', dest);\n            if (file) {\n                fd.append('filename', file.filename);\n            }\n            if (options) {\n                Object.keys(options).forEach(key => {\n                    if (key !== 'meta' && typeof options[key] !== 'function') {\n                        fd.append(key, String(options[key]));\n                    }\n                });\n            }\n            if (file instanceof window.ArrayBuffer) {\n                fd.append('size', String(file.byteLength));\n            }\n            FS.addFormFile(fd, 'upload', file, options.meta);\n            return this._request('upload', fd, options);\n        }\n        scandir(item, options) {\n            options = options || {};\n            const args = {\n                path: item.path,\n                options: { shortcuts: options.shortcuts }\n            };\n            return new Promise((resolve, reject) => {\n                this._request('scandir', args, options).then(result => {\n                    return resolve(result.map(i => new FileMetadata(i)));\n                }).catch(reject);\n            });\n        }\n        read(item, options) {\n            return this._request('get', { path: item.path }, options);\n        }\n        write(file, data, options) {\n            options = options || {};\n            options.meta = file;\n            options.overwrite = true;\n            options.onprogress = options.onprogress || function () {\n            };\n            const parentfile = new FileMetadata(FS.dirname(file.path), file.mime);\n            return this._requestUpload(parentfile, data, options);\n        }\n        unlink(src) {\n            return this._request('unlink', { path: src.path });\n        }\n        copy(src, dest, options) {\n            return this._request('copy', {\n                src: src.path,\n                dest: dest.path\n            }, options);\n        }\n        move(src, dest, options) {\n            return this._request('move', {\n                src: src.path,\n                dest: dest.path\n            }, options);\n        }\n        exists(item) {\n            return this._request('exists', { path: item.path });\n        }\n        fileinfo(item) {\n            return this._request('fileinfo', { path: item.path });\n        }\n        mkdir(dir) {\n            return this._request('mkdir', { path: dir.path });\n        }\n        upload(dest, data, options) {\n            return this._requestUpload(dest, data, options);\n        }\n        url(item, options) {\n            if (typeof item === 'string') {\n                item = new FileMetadata(item);\n            }\n            return Promise.resolve(Connection.instance.getVFSPath(item, options));\n        }\n        find(file, options) {\n            return this._request('find', {\n                path: file.path,\n                args: options\n            });\n        }\n        trash(file) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_UNAVAILABLE')));\n        }\n        untrash(file) {\n            return Promise.reject(new Error(Locales._('ERR_VFS_UNAVAILABLE')));\n        }\n        emptyTrash() {\n            return Promise.reject(new Error(Locales._('ERR_VFS_UNAVAILABLE')));\n        }\n        freeSpace(root) {\n            return this._request('freeSpace', { root: root });\n        }\n    };\n});"]}