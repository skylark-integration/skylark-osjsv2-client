{"version":3,"sources":["vfs/transports/web.js"],"names":["define","axios","Transport","Connection","FS","[object Object]","url","responseType","method","options","Promise","resolve","reject","cors","then","response","statusText","data","catch","e","Error","message","binary","type","request","result","dataSourceToAb","body","err","ab","item","mount","root","option","path","replace","this","_request","map","iter","mime","abToText","txt","toUpperCase"],"mappings":";;;;;;;AAAAA,QACI,gBACA,eACA,wBACA,kBACD,SAAUC,EAAOC,EAAWC,EAAYC,GACvC,aACA,qBAAkCF,EAC9BG,SAASC,EAAKC,EAAcC,EAAQC,GAChC,OAAO,IAAIC,QAAQ,CAACC,EAASC,KACzB,GAAKH,EAAQI,KAeTZ,GACIM,aAAcA,EACdD,IAAKA,EACLE,OAAQA,IACTM,KAAKC,GACGJ,EAAyB,OAAjBJ,EAAwBQ,EAASC,WAAaD,EAASE,OACvEC,MAAMC,GAAKP,EAAO,IAAIQ,MAAMD,EAAEE,SAAWF,SArB7B,CACf,MAAMG,EAA0B,SAAjBb,EAAQc,MAA2C,gBAAjBhB,EACjDJ,EAAWqB,QAAQ,QACflB,IAAKA,EACLE,OAAQA,EACRc,OAAQA,IACTR,KAAKW,GACAH,EACOlB,EAAGsB,eAAeD,EAAOE,KAAM,2BAA4B,CAACC,EAAKC,IAC7DD,EAAMhB,EAAOgB,GAAOjB,EAAQkB,IAGpClB,EAAQc,EAAOE,OACvBT,MAAMN,MAYrBP,QAAQyB,EAAMrB,EAASsB,GACnB,OAAO,IAAIrB,QAAQ,CAACC,EAASC,KACzB,MAAMoB,EAAOD,EAAME,OAAO,QACpB3B,EAAMwB,EAAKI,KAAKC,QAAQ,OAAQ,kBACtCC,KAAKC,SAAS/B,EAAK,OAAQ,MAAOG,GAASK,KAAKC,GACrCJ,EAAQI,EAASuB,IAAIC,IACxBA,EAAKL,KAAOF,EAAOO,EAAKL,KAAKC,QAAQ,MAAO,IACrCI,MAEZrB,MAAMN,KAGjBP,KAAKyB,EAAMrB,GACP,MAAM+B,EAAOV,EAAKU,MAAQ,2BAC1B,OAAO,IAAI9B,QAAQ,CAACC,EAASC,KACzBwB,KAAKC,SAASP,EAAKI,KAAM,cAAe,MAAOzB,GAASK,KAAKC,GACrDN,EAAQI,MACa,SAAjBJ,EAAQc,KACRZ,EAAQI,GAERX,EAAGsB,eAAeX,EAAU,2BAA4B,CAACa,EAAKC,IACnDD,EAAMhB,EAAOgB,GAAOjB,EAAQkB,KAGpC,GAEU,SAAjBpB,EAAQc,MACRnB,EAAGqC,SAAS1B,EAAUyB,EAAM,CAACZ,EAAKc,KAC1Bd,EACAhB,EAAO,IAAIQ,MAAMQ,IAEjBjB,EAAQ+B,MAGT,GAEJ/B,EAAQI,IAChBG,MAAMN,KAGjBP,OAAOyB,GACH,OAAO,IAAIpB,QAAQ,CAACC,EAASC,KACzBwB,KAAKC,SAASP,EAAKI,KAAM,KAAM,QAAQpB,KAAKC,GACjCJ,EAAmC,OAA3BI,EAAS4B,gBACzBzB,MAAMN,KAGjBP,IAAIyB,GACA,OAAOpB,QAAQC,QAAQmB,EAAKI","file":"../../../vfs/transports/web.js","sourcesContent":["define([\n    'skylark-axios',\n    '../transport',\n    '../../core/connection',\n    '../../utils/fs'\n], function (axios, Transport, Connection, FS) {\n    'use strict';\n    return class WebTransport extends Transport {\n        _request(url, responseType, method, options) {\n            return new Promise((resolve, reject) => {\n                if (!options.cors) {\n                    const binary = options.type === 'text' ? false : responseType === 'arraybuffer';\n                    Connection.request('curl', {\n                        url: url,\n                        method: method,\n                        binary: binary\n                    }).then(result => {\n                        if (binary) {\n                            return FS.dataSourceToAb(result.body, 'application/octet-stream', (err, ab) => {\n                                return err ? reject(err) : resolve(ab);\n                            });\n                        }\n                        return resolve(result.body);\n                    }).catch(reject);\n                } else {\n                    axios({\n                        responseType: responseType,\n                        url: url,\n                        method: method\n                    }).then(response => {\n                        return resolve(responseType === null ? response.statusText : response.data);\n                    }).catch(e => reject(new Error(e.message || e)));\n                }\n            });\n        }\n        scandir(item, options, mount) {\n            return new Promise((resolve, reject) => {\n                const root = mount.option('root');\n                const url = item.path.replace(/\\/?$/, '/_scandir.json');\n                this._request(url, 'json', 'GET', options).then(response => {\n                    return resolve(response.map(iter => {\n                        iter.path = root + iter.path.replace(/^\\//, '');\n                        return iter;\n                    }));\n                }).catch(reject);\n            });\n        }\n        read(item, options) {\n            const mime = item.mime || 'application/octet-stream';\n            return new Promise((resolve, reject) => {\n                this._request(item.path, 'arraybuffer', 'GET', options).then(response => {\n                    if (options.cors) {\n                        if (options.type === 'text') {\n                            resolve(response);\n                        } else {\n                            FS.dataSourceToAb(response, 'application/octet-stream', (err, ab) => {\n                                return err ? reject(err) : resolve(ab);\n                            });\n                        }\n                        return true;\n                    }\n                    if (options.type === 'text') {\n                        FS.abToText(response, mime, (err, txt) => {\n                            if (err) {\n                                reject(new Error(err));\n                            } else {\n                                resolve(txt);\n                            }\n                        });\n                        return true;\n                    }\n                    return resolve(response);\n                }).catch(reject);\n            });\n        }\n        exists(item) {\n            return new Promise((resolve, reject) => {\n                this._request(item.path, null, 'HEAD').then(response => {\n                    return resolve(response.toUpperCase() === 'OK');\n                }).catch(reject);\n            });\n        }\n        url(item) {\n            return Promise.resolve(item.path);\n        }\n    };\n});"]}