{"version":3,"sources":["vfs/transports/webdav.js"],"names":["define","axios","Connection","FS","Utils","Transport","FileMetadata","a","b","getTargetPath","item","mount","path","replace","option","getTargetUrl","file","moduleOptions","baseUrl","host","cors","parseurl","username","password","url","basename","parseListing","doc","root","reqpath","ns","substr","children","map","c","uri","getElementsByTagNameNS","textContent","length","e","console","warn","getFilePath","type","match","id","getFileId","filename","size","parseInt","getFileSize","mime","getFileMime","filter","iter","[object Object]","method","args","options","raw","headers","dest","Destination","Promise","resolve","reject","aopts","responseType","data","auth","then","response","catch","Error","message","copts","binary","request","code","httpCode","_","indexOf","error","dataSourceToAb","body","err","ab","DOMParser","parseFromString","firstChild","this","_request","src","requestUrl","getConfig","encodeURIComponent"],"mappings":"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","file":"../../../vfs/transports/webdav.js","sourcesContent":["define([\n    'skylark-axios',\n    '../../core/connection',\n    '../../utils/fs',\n    '../../utils/misc',\n    '../transport',\n    '../file',\n    '../../core/config',\n    '../../core/locales'\n], function (axios, Connection, FS, Utils, Transport, FileMetadata, a, b) {\n    'use strict';\n    function getTargetPath(item, mount) {\n        return item.path.replace(mount.option('match'), '');\n    }\n    function getTargetUrl(mount, file, moduleOptions) {\n        let baseUrl = moduleOptions.host;\n        if (!moduleOptions.cors) {\n            baseUrl = Utils.parseurl(moduleOptions.host, {\n                username: moduleOptions.username,\n                password: moduleOptions.password\n            }).url;\n        }\n        const basename = getTargetPath(file, mount);\n        return baseUrl.replace(/\\/?$/, basename.replace(/^\\/?/, '/'));\n    }\n    function getFilePath(c, ns, mount) {\n        const moduleOptions = mount.option('options') || {};\n        const uri = Utils.parseurl(moduleOptions.host).path;\n        try {\n            let path = c.getElementsByTagNameNS(ns, 'href')[0].textContent;\n            return path.substr(uri.length - 1, path.length);\n        } catch (e) {\n            console.warn(e);\n        }\n        return '/';\n    }\n    function getFileMime(type, c, ns) {\n        if (type === 'file') {\n            try {\n                return c.getElementsByTagNameNS(ns, 'getcontenttype')[0].textContent || 'application/octet-stream';\n            } catch (e) {\n                return 'application/octet-stream';\n            }\n        }\n        return null;\n    }\n    function getFileId(type, c, ns) {\n        try {\n            return c.getElementsByTagNameNS(ns, 'getetag')[0].textContent;\n        } catch (e) {\n        }\n        return null;\n    }\n    function getFileSize(type, c, ns) {\n        if (type === 'file') {\n            try {\n                return parseInt(c.getElementsByTagNameNS(ns, 'getcontentlength')[0].textContent, 10) || 0;\n            } catch (e) {\n            }\n        }\n        return 0;\n    }\n    function parseListing(doc, item, mount) {\n        const root = mount.option('root');\n        const moduleOptions = mount.option('options') || {};\n        const reqpath = getTargetPath(item, mount);\n        let ns = moduleOptions.ns || 'DAV';\n        if (ns.substr(-1) !== ':') {\n            ns += ':';\n        }\n        return (doc.children || []).map(c => {\n            let path = getFilePath(c, ns, mount);\n            let type = 'file';\n            if (path.match(/\\/$/)) {\n                type = 'dir';\n                path = path.replace(/\\/$/, '') || '/';\n            }\n            if (path === reqpath) {\n                return false;\n            }\n            return new FileMetadata({\n                id: getFileId(type, c, ns),\n                path: root + path.replace(/^\\//, ''),\n                filename: FS.filename(path),\n                size: getFileSize(type, c, ns),\n                mime: getFileMime(type, c, ns),\n                type: type\n            });\n        }).filter(iter => iter !== false);\n    }\n    function parseResponse(body) {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(body, 'application/xml');\n        return doc.firstChild;\n    }\n    return class WebDAVTransport extends Transport {\n        _request(method, args, options, mount, raw) {\n            const mime = args.mime || 'application/octet-stream';\n            const file = new FileMetadata(args, mime);\n            const moduleOptions = mount.option('options') || {};\n            const headers = {};\n            const url = getTargetUrl(mount, file, moduleOptions);\n            if (args.dest) {\n                const dest = new FileMetadata(args.dest, mime);\n                headers.Destination = getTargetUrl(mount, dest, moduleOptions);\n            }\n            if (mime) {\n                headers['Content-Type'] = mime;\n            }\n            return new Promise((resolve, reject) => {\n                if (moduleOptions.cors) {\n                    const aopts = {\n                        url: url,\n                        responseType: raw === true ? 'arraybuffer' : 'text',\n                        method: method,\n                        headers: headers,\n                        data: args.data,\n                        auth: {\n                            username: moduleOptions.username,\n                            password: moduleOptions.password\n                        }\n                    };\n                    axios(aopts).then(response => {\n                        return resolve(response.data);\n                    }).catch(e => reject(new Error(e.message || e)));\n                } else {\n                    const copts = {\n                        url: url,\n                        method: method,\n                        binary: raw === true,\n                        mime: mime,\n                        headers: headers\n                    };\n                    Connection.request('curl', copts).then(response => {\n                        const code = response.httpCode;\n                        if (!response) {\n                            return reject(new Error(b._('ERR_VFS_REMOTEREAD_EMPTY')));\n                        } else if ([\n                                200,\n                                201,\n                                203,\n                                204,\n                                205,\n                                207\n                            ].indexOf(code) < 0) {\n                            const error = new Error(b._('ERR_VFSMODULE_XHR_ERROR') + ': ' + code);\n                            error.httpCode = code;\n                            return reject(error);\n                        }\n                        if (raw === true) {\n                            return FS.dataSourceToAb(response.body, mime, (err, ab) => {\n                                return err ? reject(new Error(err)) : resolve(ab);\n                            });\n                        }\n                        return resolve(parseResponse(response.body));\n                    }).catch(reject);\n                }\n            });\n        }\n        scandir(item, options, mount) {\n            return new Promise((resolve, reject) => {\n                this._request('PROPFIND', { path: item.path }, options, mount).then(doc => {\n                    resolve(doc ? parseListing(doc, item, mount).map(iter => new FileMetadata(iter)) : []);\n                }).catch(reject);\n            });\n        }\n        read(item, options, mount) {\n            return this._request('GET', {\n                path: item.path,\n                mime: item.mime\n            }, options, mount, true);\n        }\n        write(item, data, options, mount) {\n            return this._request('PUT', {\n                path: item.path,\n                data: data,\n                mime: item.mime\n            }, options, mount);\n        }\n        unlink(item, options, mount) {\n            return this._request('DELETE', { path: item.path }, options, mount);\n        }\n        copy(src, dest, options, mount) {\n            return this._request('COPY', {\n                path: src.path,\n                dest: dest.path\n            }, options, mount);\n        }\n        move(src, dest, options, mount) {\n            return this._request('MOVE', {\n                path: src.path,\n                dest: dest.path\n            }, options, mount);\n        }\n        exists(item, options, mount) {\n            return new Promise((resolve, reject) => {\n                this._request('PROPFIND', { path: item.path }, options, mount).then(() => {\n                    resolve(false);\n                }).catch(err => {\n                    if (err.httpCode === 404) {\n                        resolve(false);\n                    } else {\n                        console.warn(err);\n                        resolve(true);\n                    }\n                });\n            });\n        }\n        mkdir(item, options, mount) {\n            return this._request('MKCOL', { path: item.path }, options, mount);\n        }\n        url(item, options, mount) {\n            const moduleOptions = mount.option('options') || {};\n            let requestUrl = getTargetUrl(mount, item, moduleOptions);\n            if (!moduleOptions.cors) {\n                requestUrl = a.getConfig('Connection.FSURI') + '/read?path=' + encodeURIComponent(requestUrl);\n            }\n            return Promise.resolve(requestUrl);\n        }\n        freeSpace(root) {\n            return Promise.resolve(-1);\n        }\n    };\n});"]}