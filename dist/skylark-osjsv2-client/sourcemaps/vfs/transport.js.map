{"version":3,"sources":["vfs/transport.js"],"names":["define","axios","a","[object Object]","method","args","options","mount","readOnly","isReadOnly","indexOf","Promise","reject","Error","_","newArgs","concat","this","item","file","data","src","dest","dir","resolve","url","then","responseType","result","catch","error","message","root"],"mappings":";;;;;;;AAAAA,QACI,gBACA,mBACD,SAAUC,EAAOC,GAChB,aACA,aACIC,QAAQC,EAAQC,EAAMC,EAASC,GAC3B,MAAMC,GACF,SACA,SACA,QACA,QACA,OACA,QACA,UACA,cAEJ,GAAID,EAAME,eAC4B,IAA9BD,EAASE,QAAQN,GACjB,OAAOO,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,4BAG5C,MAAMC,EAAUV,EAAKW,QACjBV,EACAC,IAEJ,OAAOU,KAAKb,MAAWW,GAE3BZ,QAAQe,EAAMZ,EAASC,GACnB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,KAAKe,EAAMZ,EAASC,GAChB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,MAAMgB,EAAMC,EAAMd,EAASC,GACvB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,OAAOkB,EAAKf,EAASC,GACjB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,KAAKkB,EAAKC,EAAMhB,EAASC,GACrB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,KAAKkB,EAAKC,EAAMhB,EAASC,GACrB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,OAAOe,EAAMZ,EAASC,GAClB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,SAASe,EAAMZ,EAASC,GACpB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,MAAMoB,EAAKjB,EAASC,GAChB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,OAAOgB,EAAMG,EAAMhB,EAASC,GACxB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,SAASe,EAAMZ,EAASC,GACpB,OAAO,IAAII,QAAQ,CAACa,EAASZ,KACzBK,KAAKQ,IAAIP,GAAMQ,KAAKD,GACTxB,GACH0B,aAAc,cACdF,IAAKA,EACLrB,OAAQ,QACTsB,KAAKE,GACGJ,EAAQI,EAAOR,OACvBS,MAAMC,IACLlB,EAAOkB,EAAMC,YAElBF,MAAMjB,KAGjBT,IAAIe,EAAMZ,EAASC,GACf,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,KAAKgB,EAAMb,EAASC,GAChB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,MAAMgB,EAAMb,EAASC,GACjB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,QAAQgB,EAAMb,EAASC,GACnB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,WAAWG,EAASC,GAChB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE,yBAExCX,UAAU6B,EAAM1B,EAASC,GACrB,OAAOI,QAAQC,OAAO,IAAIC,MAAMX,EAAEY,EAAE","file":"../../vfs/transport.js","sourcesContent":["define([\n    'skylark-axios',\n    '../core/locales'\n], function (axios, a) {\n    'use strict';\n    return class Transport {\n        request(method, args, options, mount) {\n            const readOnly = [\n                'upload',\n                'unlink',\n                'write',\n                'mkdir',\n                'move',\n                'trash',\n                'untrash',\n                'emptyTrash'\n            ];\n            if (mount.isReadOnly()) {\n                if (readOnly.indexOf(method) !== -1) {\n                    return Promise.reject(new Error(a._('ERR_VFSMODULE_READONLY')));\n                }\n            }\n            const newArgs = args.concat([\n                options,\n                mount\n            ]);\n            return this[method](...newArgs);\n        }\n        scandir(item, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        read(item, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        write(file, data, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        unlink(src, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        copy(src, dest, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        move(src, dest, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        exists(item, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        fileinfo(item, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        mkdir(dir, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        upload(file, dest, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        download(item, options, mount) {\n            return new Promise((resolve, reject) => {\n                this.url(item).then(url => {\n                    return axios({\n                        responseType: 'arraybuffer',\n                        url: url,\n                        method: 'GET'\n                    }).then(result => {\n                        return resolve(result.data);\n                    }).catch(error => {\n                        reject(error.message);\n                    });\n                }).catch(reject);\n            });\n        }\n        url(item, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        find(file, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        trash(file, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        untrash(file, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        emptyTrash(options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n        freeSpace(root, options, mount) {\n            return Promise.reject(new Error(a._('ERR_VFS_UNAVAILABLE')));\n        }\n    };\n});"]}