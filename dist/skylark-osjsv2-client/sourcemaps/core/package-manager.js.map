{"version":3,"sources":["core/package-manager.js"],"names":["define","SettingsManager","misc","locales","config","FS","Connection","resolvePreloads","metadata","pm","packageURI","getConfig","mapIter","s","src","additions","list","preload","slice","map","depends","Array","forEach","k","OSjs","Applications","pkg","getPackage","console","info","concat","pkgs","getPackages","Object","keys","pn","p","type","uses","name","match","scope","VFS","url","pathJoin","path","then","[object Object]","this","packages","blacklist","Authenticator","isStandalone","debug","Promise","resolve","reject","setPackages","_loadMetadata","length","Error","_","catch","paths","instance","get","request","command","args","res","cb","action","result","currLocale","getLocale","i","newIter","cloneObject","names","descriptions","description","file","root","dest","filename","replace","zip","generateUserMetadata","opts","repos","entries","all","yes","no","method","body","JSON","parse","e","iter","_repository","freeze","filtered","hidden","allowed","indexOf","groups","checkPermission","mime","a","checkAcceptMime","push","app","vfspath","appname","__pname","fsuri","substr","locale","checkEntry","key","assign","resolveIcon","icon","packagePath","each","className","warn"],"mappings":"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","file":"../../core/package-manager.js","sourcesContent":["define([\n    './settings-manager',\n    '../utils/misc',\n    './locales',\n    './config',\n    '../utils/fs',\n    './connection'\n], function ( SettingsManager, misc, locales, config, FS, Connection) {\n    'use strict';\n    const resolvePreloads = (metadata, pm) => {\n        const packageURI = config.getConfig('Connection.PackageURI');\n        const mapIter = s => typeof s === 'string' ? { src: s } : s;\n        let additions = [];\n        let list = (metadata.preload || []).slice(0).map(mapIter);\n        if (metadata.depends instanceof Array) {\n            metadata.depends.forEach(k => {\n                if (!OSjs.Applications[k]) {\n                    const pkg = pm.getPackage(k);\n                    if (pkg) {\n                        console.info('Using dependency', k);\n                        additions = additions.concat(pkg.preload.map(mapIter));\n                    }\n                }\n            });\n        }\n        const pkgs = pm.getPackages(false); \n        Object.keys(pkgs).forEach(pn => {\n            const p = pkgs[pn];\n            if (p.type === 'extension' && p.uses === name) {\n                if (p) {\n                    console.info('Using extension', pn);\n                    additions = additions.concat(p.preload.map(mapIter));\n                }\n            }\n        });\n        return additions.concat(list).map(p => {\n            if (!p.src.match(/^(\\/|https?|ftp)/)) {\n                if (metadata.scope === 'user') {\n                    pm.VFS.url(FS.pathJoin(metadata.path, p.src)).then(url => {\n                        p.src = url;\n                        return true;\n                    });\n                } else {\n                    p.src = FS.pathJoin(packageURI, metadata.path, p.src);\n                }\n            }\n            return p;\n        });\n    };\n    class PackageManager {\n        constructor() { \n            this.packages = {};\n            this.blacklist = [];\n        }\n        destroy() {\n            this.packages = {};\n            this.blacklist = [];\n        }\n        init(Authenticator,VFS, metadata, isStandalone) { // modified by lwf\n            this.Authenticator = Authenticator;\n            this.VFS = VFS;\n            console.debug('PackageManager::load()', metadata);\n            return new Promise((resolve, reject) => {\n                const setPackages = metadata ? this.setPackages(metadata) : Promise.resolve();\n                setPackages.then(() => {\n                    if (isStandalone) {\n                        return resolve(true);\n                    }\n                    return this._loadMetadata().then(() => {\n                        const len = Object.keys(this.packages).length;\n                        if (len) {\n                            return resolve(true);\n                        }\n                        return reject(new Error(locales._('ERR_PACKAGE_ENUM_FAILED')));\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n        _loadMetadata() {\n            const paths = SettingsManager.instance('PackageManager').get('PackagePaths', []);\n            return new Promise((resolve, reject) => {\n                Connection.request('packages', {\n                    command: 'list',\n                    args: { paths: paths }\n                }).then(res => {\n                    return this.setPackages(res).then(resolve).catch(reject);\n                }).catch(reject);\n            });\n        }\n        generateUserMetadata() {\n            const paths = SettingsManager.instance('PackageManager').get('PackagePaths', []);\n            return new Promise((resolve, reject) => {\n                const cb = () => this._loadMetadata().then(resolve).catch(reject);\n                Connection.request('packages', {\n                    command: 'cache',\n                    args: {\n                        action: 'generate',\n                        scope: 'user',\n                        paths: paths\n                    }\n                }).then(cb).catch(cb);\n            });\n        }\n        _addPackages(result, scope) {\n            console.debug('PackageManager::_addPackages()', result);\n            const keys = Object.keys(result);\n            if (!keys.length) {\n                return;\n            }\n            const currLocale = locales.getLocale();\n            keys.forEach(i => {\n                const newIter = misc.cloneObject(result[i]);\n                if (typeof newIter !== 'object') {\n                    return;\n                }\n                if (typeof newIter.names !== 'undefined' && newIter.names[currLocale]) {\n                    newIter.name = newIter.names[currLocale];\n                }\n                if (typeof newIter.descriptions !== 'undefined' && newIter.descriptions[currLocale]) {\n                    newIter.description = newIter.descriptions[currLocale];\n                }\n                if (!newIter.description) {\n                    newIter.description = newIter.name;\n                }\n                newIter.scope = scope || 'system';\n                newIter.type = newIter.type || 'application';\n                this.packages[i] = newIter;\n            });\n        }\n        install(file, root) {\n            const paths = SettingsManager.instance('PackageManager').get('PackagePaths', []);\n            if (typeof root !== 'string') {\n                root = paths[0];\n            }\n            const dest = FS.pathJoin(root, file.filename.replace(/\\.zip$/i, ''));\n            return new Promise((resolve, reject) => {\n                Connection.request('packages', {\n                    command: 'install',\n                    args: {\n                        zip: file.path,\n                        dest: dest,\n                        paths: paths\n                    }\n                }).then(() => {\n                    return this.generateUserMetadata().then(resolve).catch(reject);\n                }).catch(reject);\n            });\n        }\n        uninstall(file) {\n            return new Promise((resolve, reject) => {\n                Connection.request('packages', {\n                    command: 'uninstall',\n                    args: { path: file.path }\n                }).then(() => {\n                    return this.generateUserMetadata().then(resolve).catch(reject);\n                }).catch(reject);\n            });\n        }\n        setBlacklist(list) {\n            this.blacklist = list || [];\n        }\n        getStorePackages(opts) {\n            const repos = SettingsManager.instance('PackageManager').get('Repositories', []);\n            let entries = [];\n            return new Promise((resolve, reject) => {\n                Promise.all(repos.map(url => {\n                    return new Promise((yes, no) => {\n                        Connection.request('curl', {\n                            url: url,\n                            method: 'GET'\n                        }).then(result => {\n                            let list = [];\n                            if (typeof result.body === 'string') {\n                                try {\n                                    list = JSON.parse(result.body);\n                                } catch (e) {\n                                }\n                            }\n                            entries = entries.concat(list.map(iter => {\n                                iter._repository = url;\n                                return iter;\n                            }));\n                            return yes();\n                        }).catch(no);\n                    });\n                })).then(() => resolve(entries)).catch(reject);\n            });\n        }\n        getPackage(name) {\n            if (typeof this.packages[name] !== 'undefined') {\n                return Object.freeze(misc.cloneObject(this.packages)[name]);\n            }\n            return false;\n        }\n        getPackages(filtered) {\n            const Authenticator = this.Authenticator;\n\n            const hidden = SettingsManager.instance('PackageManager').get('Hidden', []);\n            const p = misc.cloneObject(this.packages);\n            const allowed = iter => {\n                if (this.blacklist.indexOf(iter.path) >= 0) {\n                    return false;\n                }\n                if (iter && iter.groups instanceof Array) {\n                    if (!Authenticator.instance().checkPermission(iter.groups)) { // modified by lwf\n                        return false;\n                    }\n                }\n                return true;\n            };\n            if (typeof filtered === 'undefined' || filtered === true) {\n                const result = {};\n                Object.keys(p).forEach(name => {\n                    const iter = p[name];\n                    if (!allowed(iter)) {\n                        return;\n                    }\n                    if (iter && hidden.indexOf(name) < 0) {\n                        result[name] = iter;\n                    }\n                });\n                return Object.freeze(result);\n            }\n            return Object.freeze(p);\n        }\n        getPackagesByMime(mime) {\n            const list = [];\n            const p = misc.cloneObject(this.packages);\n            Object.keys(p).forEach(i => {\n                if (this.blacklist.indexOf(i) < 0) {\n                    const a = p[i];\n                    if (a && a.mime) {\n                        if (FS.checkAcceptMime(mime, a.mime)) {\n                            list.push(i);\n                        }\n                    }\n                }\n            });\n            return list;\n        }\n        getPackageResource(app, name, vfspath) {\n            if (name.match(/^((https?:)|\\.)?\\//)) {\n                return name;\n            }\n            name = name.replace(/^\\.\\//, '');\n            const appname = typeof app === 'string' ? app : app.__pname;\n            const fsuri = config.getConfig('Connection.FSURI');\n            const pkg = this.getPackage(appname);\n            let path = name;\n            if (pkg) {\n                path = pkg.scope === 'user' ? '/user-package/' + FS.filename(pkg.path) + '/' + name.replace(/^\\//, '') : 'packages/' + pkg.path + '/' + name;\n                if (vfspath) {\n                    return pkg.scope === 'user' ? path.substr(fsuri.length) : config.getConfig('VFS.Dist') + path;\n                }\n            }\n            return path;\n        }\n        setPackages(res) { \n            const packages = {};\n            const locale = locales.getLocale();\n            const checkEntry = (key, iter, scope) => {\n                iter = Object.assign({}, iter);\n                iter.type = iter.type || 'application';\n                if (scope) {\n                    iter.scope = scope;\n                }\n                if (iter.names && iter.names[locale]) {\n                    iter.name = iter.names[locale];\n                }\n                if (iter.descriptions && iter.descriptions[locale]) {\n                    iter.description = iter.descriptions[locale];\n                }\n                let resolveIcon = () => {\n                    if (iter.icon && iter.path) {\n                        let packagePath = iter.path.replace(/^\\//, '');\n                        if (iter.scope === 'user') {\n                            return this.VFS.url(FS.pathJoin(packagePath, iter.icon));\n                        } else {\n                            if (iter.icon.match(/^\\.\\//)) {\n                                const packageURI = config.getConfig('Connection.PackageURI').replace(/\\/?$/, '/');\n                                return Promise.resolve(packageURI + packagePath + iter.icon.replace(/^\\./, ''));\n                            }\n                        }\n                    }\n                    return Promise.resolve(iter.icon);\n                };\n                iter.preload = resolvePreloads(iter, this); \n                return new Promise((resolve, reject) => {\n                    resolveIcon().then(icon => {\n                        if (icon) {\n                            iter.icon = icon;\n                        }\n                        return resolve(iter);\n                    }).catch(reject);\n                });\n            };\n            return new Promise((resolve, reject) => {\n                const entries = Object.keys(res || {});\n                Promise.each(entries, key => {\n                    return new Promise((yes, no) => {\n                        const iter = res[key];\n                        if (iter && !packages[iter.className]) {\n                            checkEntry(key, iter).then(pkg => {\n                                packages[iter.className] = pkg;\n                                return yes();\n                            }).catch(no);\n                        } else {\n                            console.warn('No such package', key);\n                            yes();\n                        }\n                    });\n                }).catch(reject).then(() => {\n                    this.packages = packages;\n                    return resolve();\n                });\n            });\n        }\n    }\n    return new PackageManager();\n});"]}