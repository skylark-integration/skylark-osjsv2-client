{"version":3,"sources":["core/mount-manager.js"],"names":["define","Mountpoint","Locales","Config","[object Object]","this","inited","mountpoints","loadTransports","Promise","resolve","transports","config","getConfig","enabled","Object","keys","filter","name","each","iter","assign","dynamic","add","notify","then","catch","e","console","warn","String","mountPoints","point","mount","options","transport","T","reject","Error","m","option","length","_","push","info","moduleName","module","getModule","index","unmount","res","splice","visible","special","filterName","test","find","match","idx","i"],"mappings":";;;;;;;AAAAA,QACI,oBACA,YACA,YACD,SAAUC,EAAYC,EAASC,GAC9B,aAyHA,OAAO,UAtHHC,cACIC,KAAKC,QAAS,EACdD,KAAKE,eAGTH,KAAKI,GACD,GAAIH,KAAKC,OACL,OAAOG,QAAQC,UAEnBL,KAAKM,WAAaH,IAClBH,KAAKC,QAAS,EACd,MAAMM,EAAST,EAAOU,UAAU,sBAC1BC,EAAUC,OAAOC,KAAKJ,GAAQK,OAAOC,IACP,IAAzBN,EAAOM,GAAMJ,SAExB,OAAOL,QAAQU,KAAKL,EAASI,GAClB,IAAIT,QAAQC,IACf,MAAMU,EAAOL,OAAOM,QAChBH,KAAMA,EACNI,SAAS,GACVV,EAAOM,IACVb,KAAKkB,IAAIH,GAAM,GAAQI,QAAQ,IAASC,KAAKf,GAASgB,MAAMC,IACxDC,QAAQC,KAAK,gCAAiCX,EAAME,EAAMU,OAAOH,IAC1DjB,GAAQ,QAK/BN,QAAQ2B,GACJ,OAAOtB,QAAQU,KAAKY,EAAaX,GAAQf,KAAKkB,IAAIH,IAEtDhB,IAAI4B,EAAOC,EAAOC,GACd,IACI,KAAMF,aAAiB/B,GAAa,CAChC,GAA+B,iBAApB+B,EAAMG,UAAwB,CACrC,MAAMC,EAAI/B,KAAKM,WAAWqB,EAAMG,WAChC,IAAKC,EACD,OAAO3B,QAAQ4B,OAAO,IAAIC,MAAM,sBAAwBN,EAAMG,YAElEH,EAAMG,UAAY,IAAIC,EAE1BJ,EAAQ,IAAI/B,EAAW+B,GAW3B,GATc3B,KAAKE,YAAYU,OAAOsB,GAC9BA,EAAEC,OAAO,UAAYR,EAAMQ,OAAO,SAGlCD,EAAEC,OAAO,UAAYR,EAAMQ,OAAO,SAKhCC,OACN,OAAOhC,QAAQ4B,OAAO,IAAIC,MAAMpC,EAAQwC,EAAE,oCAAqCV,EAAMQ,OAAO,WAEhGnC,KAAKE,YAAYoC,KAAKX,GACxB,MAAOL,GACL,OAAOlB,QAAQ4B,OAAOV,GAG1B,OADAC,QAAQgB,KAAK,WAAYZ,GAClB,IAAIvB,QAAQ,CAACC,EAAS2B,KACrBJ,EACAD,EAAMC,QAAQR,KAAK,IACRf,EAAQsB,IAChBN,MAAMW,GAET3B,EAAQsB,KAIpB5B,OAAOyC,EAAYX,GACf,MAAMY,OAASzC,KAAK0C,UAAUF,GACxBG,EAAQ3C,KAAK0C,UAAUF,GAAY,GACzC,OAAIC,OACO,IAAIrC,QAAQ,CAACC,EAAS2B,KACzBS,OAAOG,QAAQf,GAAST,KAAKyB,KACV,IAAXF,GACA3C,KAAKE,YAAY4C,OAAOH,EAAO,GAE5BtC,EAAQwC,KAChBxB,MAAMW,KAGV5B,QAAQ4B,OAAO,IAAIC,MAAMpC,EAAQwC,EAAE,gCAAiCG,KAE/EzC,WAAWa,GAKP,OAJAA,EAASF,OAAOM,WACZ+B,SAAS,EACTC,SAAS,GACVpC,GACIZ,KAAKE,YAAYU,OAAOgB,MACvBA,EAAMnB,YAAamB,EAAMO,OAAO,aACnBzB,OAAOC,KAAKC,GAAQA,OAAOqC,GAC7BrB,EAAMO,OAAOc,KAAgBrC,EAAOqC,IAEnCb,OAAS,GAKjCrC,kBAAkBmD,GACd,OAAOlD,KAAKE,YAAYiD,KAAKvB,MACL,iBAATsB,GAAqBtB,EAAMnB,WAC9BmB,EAAMO,OAAO,UAAYe,EAAKE,MAAMxB,EAAMO,OAAO,YAOjEpC,UAAUc,EAAMwC,GACZ,MAAMnB,EAAImB,EAAM,YAAc,OAC9B,OAAOrD,KAAKE,YAAYgC,GAAGoB,GAAKA,EAAEnB,OAAO,UAAYtB,GAEzDd,aAAac,GACT,OAAOb,KAAKM,WAAWO","file":"../../core/mount-manager.js","sourcesContent":["define([\n    '../vfs/mountpoint',\n    './locales',\n    './config'\n], function (Mountpoint, Locales, Config) {\n    'use strict';\n\n    class MountManager {\n        constructor() {\n            this.inited = false;\n            this.mountpoints = [];\n//            this.transports = loadTransports();\n        }\n        init(loadTransports) { // modified by lwf\n            if (this.inited) {\n                return Promise.resolve();\n            }\n            this.transports = loadTransports();\n            this.inited = true;\n            const config = Config.getConfig('VFS.Mountpoints', {});\n            const enabled = Object.keys(config).filter(name => {\n                return config[name].enabled !== false;\n            });\n            return Promise.each(enabled, name => {\n                return new Promise(resolve => {\n                    const iter = Object.assign({\n                        name: name,\n                        dynamic: false\n                    }, config[name]);\n                    this.add(iter, true, { notify: false }).then(resolve).catch(e => {\n                        console.warn('Failed to init VFS Mountpoint', name, iter, String(e));\n                        return resolve(false);\n                    });\n                });\n            });\n        }\n        addList(mountPoints) {\n            return Promise.each(mountPoints, iter => this.add(iter));\n        }\n        add(point, mount, options) {\n            try {\n                if (!(point instanceof Mountpoint)) {\n                    if (typeof point.transport === 'string') {\n                        const T = this.transports[point.transport];\n                        if (!T) {\n                            return Promise.reject(new Error('No such transport: ' + point.transport));\n                        }\n                        point.transport = new T();\n                    }\n                    point = new Mountpoint(point);\n                }\n                const found = this.mountpoints.filter(m => {\n                    if (m.option('name') === point.option('name')) {\n                        return true;\n                    }\n                    if (m.option('root') === point.option('root')) {\n                        return true;\n                    }\n                    return false;\n                });\n                if (found.length) {\n                    return Promise.reject(new Error(Locales._('ERR_VFSMODULE_ALREADY_MOUNTED_FMT', point.option('name'))));\n                }\n                this.mountpoints.push(point);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n            console.info('Mounting', point);\n            return new Promise((resolve, reject) => {\n                if (mount) {\n                    point.mount().then(() => {\n                        return resolve(point);\n                    }).catch(reject);\n                } else {\n                    resolve(point);\n                }\n            });\n        }\n        remove(moduleName, options) {\n            const module = this.getModule(moduleName);\n            const index = this.getModule(moduleName, true);\n            if (module) {\n                return new Promise((resolve, reject) => {\n                    module.unmount(options).then(res => {\n                        if (index !== -1) {\n                            this.mountpoints.splice(index, 1);\n                        }\n                        return resolve(res);\n                    }).catch(reject);\n                });\n            }\n            return Promise.reject(new Error(Locales._('ERR_VFSMODULE_NOT_MOUNTED_FMT', moduleName)));\n        }\n        getModules(filter) {\n            filter = Object.assign({}, {\n                visible: true,\n                special: false\n            }, filter);\n            return this.mountpoints.filter(mount => {\n                if (mount.enabled() && mount.option('visible')) {\n                    const hits = Object.keys(filter).filter(filterName => {\n                        return mount.option(filterName) === filter[filterName];\n                    });\n                    return hits.length > 0;\n                }\n                return false;\n            });\n        }\n        getModuleFromPath(test) {\n            return this.mountpoints.find(mount => {\n                if (typeof test === 'string' && mount.enabled()) {\n                    if (mount.option('match') && test.match(mount.option('match'))) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n        }\n        getModule(name, idx) {\n            const m = idx ? 'findIndex' : 'find';\n            return this.mountpoints[m](i => i.option('name') === name);\n        }\n        getTransport(name) {\n            return this.transports[name];\n        }\n    }\n    return new MountManager();\n});"]}