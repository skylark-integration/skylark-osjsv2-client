{"version":3,"sources":["core/connection.js"],"names":["define","axios","EventHandler","Loader","a","progressHandler","ev","onprogress","lengthComputable","loaded","total","_instance","instance","[object Object]","this","offline","index","_evHandler","name","onlineFn","onOnline","offlineFn","onOffline","navigator","onLine","window","addEventListener","Promise","resolve","removeEventListener","destroy","item","options","base","getConfig","replace","defaultDist","location","protocol","path","substr","length","url","q","Object","keys","map","k","encodeURIComponent","join","mount","method","args","response","appRef","console","warn","emit","reconnecting","reject","Error","raw","requestOptions","createRequestOptions","data","ignore","forEach","key","indexOf","onUploadProgress","onDownloadProgress","appendRequestOptions","then","result","error","catch","message","realMethod","responseType","match","getVFSPath","func","on","idx","off","m","TypeError","create","indicator","createRequest","err","finally"],"mappings":";;;;;;;AAAAA,QACI,gBACA,2BACA,oBACA,YACD,SAAUC,EAAOC,EAAcC,EAAQC,GACtC,aACA,SAASC,EAAgBC,EAAIC,GACrBD,EAAGE,iBACHD,EAAWD,EAAIA,EAAGG,OAASH,EAAGI,OAE9BH,EAAWD,GAAK,GAsBxB,IAAIK,EACJ,aACIC,sBACI,OAAOD,EAEXE,cACSF,IACDA,EAAYG,MAEhBA,KAAKC,SAAU,EACfD,KAAKE,MAAQ,EACbF,KAAKG,WAAa,IAAIf,EAAagB,SACnCJ,KAAKK,SAAW,KAAML,KAAKM,YAC3BN,KAAKO,UAAY,KAAMP,KAAKQ,aAEhCT,OAKI,YAJgC,IAArBU,UAAUC,SACjBC,OAAOC,iBAAiB,UAAWZ,KAAKO,WACxCI,OAAOC,iBAAiB,SAAUZ,KAAKK,WAEpCQ,QAAQC,UAEnBf,UACIY,OAAOI,oBAAoB,UAAWf,KAAKO,WAC3CI,OAAOI,oBAAoB,SAAUf,KAAKK,UACtCL,KAAKG,aACLH,KAAKG,WAAaH,KAAKG,WAAWa,WAEtCnB,EAAY,KAEhBE,WAAWkB,EAAMC,GACbA,EAAUA,MACV,MAAMC,EAAO7B,EAAE8B,UAAU,qBAAsB,KAAKC,QAAQ,OAAQ,KAC9DC,EAAchC,EAAE8B,UAAU,YAChC,GAAiC,UAA7BT,OAAOY,SAASC,SAChB,OAAOP,EAAOE,EAAOF,EAAKQ,KAAKC,OAAOJ,EAAYK,QAAUR,EAEhE,IAAIS,EAAMtC,EAAE8B,UAAU,mBAAoB,KAO1C,GANIH,GACAW,GAAO,QACPV,EAAQO,KAAOR,EAAKQ,MAEpBG,GAAO,UAEPV,EAAS,CACT,MAAMW,EAAIC,OAAOC,KAAKb,GAASc,IAAIC,GACxBA,EAAI,IAAMC,mBAAmBhB,EAAQe,KAE5CJ,EAAEF,SACFC,GAAO,IAAMC,EAAEM,KAAK,MAG5B,OAAOP,EAEX7B,WACI,OAAQC,KAAKC,QAEjBF,YACI,OAAOC,KAAKC,QAEhBF,sBAAsBqC,EAAOC,EAAQC,EAAMC,EAAUC,GACjD,OAAO3B,QAAQC,SAAQ,GAE3Bf,WACI0C,QAAQC,KAAK,yBAA0B,mBACvC1C,KAAKC,SAAU,EACXD,KAAKG,YACLH,KAAKG,WAAWwC,KAAK,UAG7B5C,UAAU6C,GACNH,QAAQC,KAAK,0BAA2B,qBACnC1C,KAAKC,SAAWD,KAAKG,YACtBH,KAAKG,WAAWwC,KAAK,WAAYC,IAErC5C,KAAKC,SAAU,EAEnBF,cAAcsC,EAAQC,EAAMpB,GAGxB,GAFAoB,EAAOA,MACPpB,EAAUA,MACNlB,KAAKC,QACL,OAAOY,QAAQgC,OAAO,IAAIC,MAAM,kEAEpC,MAAMC,IAACA,EAAGC,eAAEA,GAAkBhD,KAAKiD,qBAAqBZ,EAAQC,GAChE,OAAO,IAAIzB,QAAQ,CAACC,EAAS+B,KACzB1D,EAxGZ,SAA8B+D,EAAMhC,GAEhC,MAAMzB,GADNyB,EAAUA,OACiBzB,YAAc,aAEnC0D,GACF,YACA,UACA,aACA,cASJ,OAPArB,OAAOC,KAAKb,GAASkC,QAAQC,KACI,IAAzBF,EAAOG,QAAQD,KACfH,EAAKG,GAAOnC,EAAQmC,MAG5BH,EAAKK,iBAAmB/D,CAAAA,GAAMD,EAAgBC,EAAIC,IAClDyD,EAAKM,mBAAqBhE,CAAAA,GAAMD,EAAgBC,EAAIC,IAC7CyD,EAuFOO,CAAqBT,EAAgB9B,IAAUwC,KAAKC,GAC/C7C,EAAQiC,EAAMY,EAAOT,MACxBU,OAAO,EACPD,OAAQA,EAAOT,QAEpBW,MAAMD,IACLf,EAAO,IAAIC,MAAMc,EAAME,SAAWF,QAI9C7D,qBAAqBsC,EAAQC,GACzB,MAAMyB,EAAa1B,EAAOhB,QAAQ,OAAQ,IAC1C,IAAI0B,GAAM,EACNC,GACAgB,aAAc,OACdpC,IAAKtC,EAAE8B,UAAU,qBAAuB,IAAM2C,EAC9C1B,OAAQ,OACRa,KAAMZ,GAcV,OAZID,EAAO4B,MAAM,UACM,QAAfF,GACAf,EAAegB,aAAe,cAC9BhB,EAAepB,IAAMU,EAAKV,KAAO5B,KAAKkE,YAAazC,KAAMa,EAAKb,OAC9DuB,EAAeX,OAASC,EAAKD,QAAU,MACvCU,GAAM,GAENC,EAAepB,IADO,WAAfmC,EACc/D,KAAKkE,aAEL5E,EAAE8B,UAAU,oBAAsB,IAAM2C,IAIjEhB,IAAAA,EACAC,eAAAA,GAGRjD,UAAUkC,EAAGkC,GACT,OAAOnE,KAAKG,WAAWiE,GAAGnC,EAAGkC,EAAMnE,MAEvCD,YAAYkC,EAAGoC,GACX,OAAOrE,KAAKG,WAAWmE,IAAIrC,EAAGoC,GAElCtE,eAAewE,EAAGjF,EAAG4B,GAGjB,OAFA5B,EAAIA,OACJ4B,EAAUA,QACwB,iBAAZA,EACXL,QAAQgC,OAAO,IAAI2B,UAAU,4CAExCnF,EAAOoF,OAAO,2BACmB,IAAtBvD,EAAQwD,kBACRxD,EAAQwD,UAEZ,IAAI7D,QAAQ,CAACC,EAAS+B,KACzB7C,KAAKF,SAAS6E,cAAcJ,EAAGjF,EAAG4B,GAASwC,KAAKnB,GACxCA,EAASqB,MACFf,EAAO,IAAIC,MAAMP,EAASqB,QAE9B9C,EAAQyB,EAASoB,SACzBE,MAAMe,IACL/B,EAAO,IAAIC,MAAM8B,MAClBC,QAAQ,KACPxF,EAAO2B,QAAQ","file":"../../core/connection.js","sourcesContent":["define([\n    'skylark-axios',\n    '../helpers/event-handler',\n    '../helpers/loader',\n    './config'\n], function (axios, EventHandler, Loader, a) {\n    'use strict';\n    function progressHandler(ev, onprogress) {\n        if (ev.lengthComputable) {\n            onprogress(ev, ev.loaded / ev.total);\n        } else {\n            onprogress(ev, -1);\n        }\n    }\n    function appendRequestOptions(data, options) {\n        options = options || {};\n        const onprogress = options.onprogress || function () {\n        };\n        const ignore = [\n            'onsuccess',\n            'onerror',\n            'onprogress',\n            'oncanceled'\n        ];\n        Object.keys(options).forEach(key => {\n            if (ignore.indexOf(key) === -1) {\n                data[key] = options[key];\n            }\n        });\n        data.onUploadProgress = ev => progressHandler(ev, onprogress);\n        data.onDownloadProgress = ev => progressHandler(ev, onprogress);\n        return data;\n    }\n    let _instance;\n    return class Connection {\n        static get instance() {\n            return _instance;\n        }\n        constructor() {\n            if (!_instance) {\n                _instance = this;\n            }\n            this.offline = false;\n            this.index = 0;\n            this._evHandler = new EventHandler(name, []);\n            this.onlineFn = () => this.onOnline();\n            this.offlineFn = () => this.onOffline();\n        }\n        init() {\n            if (typeof navigator.onLine !== 'undefined') {\n                window.addEventListener('offline', this.offlineFn);\n                window.addEventListener('online', this.onlineFn);\n            }\n            return Promise.resolve();\n        }\n        destroy() {\n            window.removeEventListener('offline', this.offlineFn);\n            window.removeEventListener('online', this.onlineFn);\n            if (this._evHandler) {\n                this._evHandler = this._evHandler.destroy();\n            }\n            _instance = null;\n        }\n        getVFSPath(item, options) {\n            options = options || {};\n            const base = a.getConfig('Connection.RootURI', '/').replace(/\\/?$/, '/');\n            const defaultDist = a.getConfig('VFS.Dist');\n            if (window.location.protocol === 'file:') {\n                return item ? base + item.path.substr(defaultDist.length) : base;\n            }\n            let url = a.getConfig('Connection.FSURI', '/');\n            if (item) {\n                url += '/read';\n                options.path = item.path;\n            } else {\n                url += '/upload';\n            }\n            if (options) {\n                const q = Object.keys(options).map(k => {\n                    return k + '=' + encodeURIComponent(options[k]);\n                });\n                if (q.length) {\n                    url += '?' + q.join('&');\n                }\n            }\n            return url;\n        }\n        isOnline() {\n            return !this.offline;\n        }\n        isOffline() {\n            return this.offline;\n        }\n        onVFSRequestCompleted(mount, method, args, response, appRef) {\n            return Promise.resolve(true);\n        }\n        onOnline() {\n            console.warn('Connection::onOnline()', 'Going online...');\n            this.offline = false;\n            if (this._evHandler) {\n                this._evHandler.emit('online');\n            }\n        }\n        onOffline(reconnecting) {\n            console.warn('Connection::onOffline()', 'Going offline...');\n            if (!this.offline && this._evHandler) {\n                this._evHandler.emit('offline', [reconnecting]);\n            }\n            this.offline = true;\n        }\n        createRequest(method, args, options) {\n            args = args || {};\n            options = options || {};\n            if (this.offline) {\n                return Promise.reject(new Error('You are currently off-line and cannot perform this operation!'));\n            }\n            const {raw, requestOptions} = this.createRequestOptions(method, args);\n            return new Promise((resolve, reject) => {\n                axios(appendRequestOptions(requestOptions, options)).then(result => {\n                    return resolve(raw ? result.data : {\n                        error: false,\n                        result: result.data\n                    });\n                }).catch(error => {\n                    reject(new Error(error.message || error));\n                });\n            });\n        }\n        createRequestOptions(method, args) {\n            const realMethod = method.replace(/^FS:/, '');\n            let raw = true;\n            let requestOptions = {\n                responseType: 'json',\n                url: a.getConfig('Connection.APIURI') + '/' + realMethod,\n                method: 'POST',\n                data: args\n            };\n            if (method.match(/^FS:/)) {\n                if (realMethod === 'get') {\n                    requestOptions.responseType = 'arraybuffer';\n                    requestOptions.url = args.url || this.getVFSPath({ path: args.path });\n                    requestOptions.method = args.method || 'GET';\n                    raw = false;\n                } else if (realMethod === 'upload') {\n                    requestOptions.url = this.getVFSPath();\n                } else {\n                    requestOptions.url = a.getConfig('Connection.FSURI') + '/' + realMethod;\n                }\n            }\n            return {\n                raw,\n                requestOptions\n            };\n        }\n        subscribe(k, func) {\n            return this._evHandler.on(k, func, this);\n        }\n        unsubscribe(k, idx) {\n            return this._evHandler.off(k, idx);\n        }\n        static request(m, a, options) {\n            a = a || {};\n            options = options || {};\n            if (options && typeof options !== 'object') {\n                return Promise.reject(new TypeError('request() expects an object as options'));\n            }\n            Loader.create('Connection.request');\n            if (typeof options.indicator !== 'undefined') {\n                delete options.indicator;\n            }\n            return new Promise((resolve, reject) => {\n                this.instance.createRequest(m, a, options).then(response => {\n                    if (response.error) {\n                        return reject(new Error(response.error));\n                    }\n                    return resolve(response.result);\n                }).catch(err => {\n                    reject(new Error(err));\n                }).finally(() => {\n                    Loader.destroy('Connection.request');\n                });\n            });\n        }\n    };\n});"]}