{"version":3,"sources":["core/process.js"],"names":["define","Connection","EventHandler","Theme","FS","Config","Compability","locales","hooks","Loader","FileMetadata","Preloader","SettingsManager","PackageManager","alreadyLaunching","runningProcesses","_kill","pid","force","res","destroy","console","warn","e","Process","[object Object]","name","args","metadata","group","length","arguments","this","__pid","push","__pname","__args","__metadata","__started","Date","__destroyed","__evHandler","__label","__path","path","__scope","scope","__iter","className","groupEnd","_emit","msg","obj","opts","sourceId","source","_app","debug","emit","substr","k","func","on","idx","off","method","options","indicator","Promise","resolve","reject","request","application","then","catch","err","Error","src","vfspath","getPackageResource","v","match","matcher","RegExp","p","getProcesses","filter","forEach","s","_onMessage","first","found","n","Array","map","getProcess","promise","data","_getSessionData","stack","__resume__","__windows__","windows","__preload__","setTimeout","create","onconstruct","hash","JSON","stringify","indexOf","remove","i","splice","fail","OSjs","error","_","compability","getCompability","getPackage","alreadyRunning","compabilityFailures","c","join","singular","triggerHook","title","icon","getIcon","pargs","max","preloadParallel","getConfig","Object","assign","onerror","preload","result","failed","Applications","instance","ResolvedPackage","settings","get","init","finally","list","info","each","spl","split","parse","getLaunchObject","file","keys","mime","filename","type","fm","val","pack","getPackagesByMime","forceList","require","default","ev","btn","set","useDefault"],"mappings":"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","file":"../../core/process.js","sourcesContent":["define([\n    './connection',\n    '../helpers/event-handler',\n    './theme',\n    '../utils/fs',\n    './config',\n    '../utils/compability',\n    './locales',\n    '../helpers/hooks',\n    '../helpers/loader',\n    '../vfs/file',\n    '../utils/preloader',\n    './settings-manager',\n    './package-manager'\n], function (\n    Connection, \n    EventHandler, \n    Theme, \n    FS, \n    Config, \n    Compability, \n    locales, \n    hooks, \n    Loader, \n    FileMetadata, \n    Preloader, \n    SettingsManager, \n    PackageManager\n) {\n    'use strict';\n    let alreadyLaunching = [];\n    let runningProcesses = [];\n    function _kill(pid, force) {\n        if (pid >= 0 && runningProcesses[pid]) {\n            try {\n                const res = runningProcesses[pid].destroy(force);\n                console.warn('Killing application', pid, res);\n                if (res !== false) {\n                    runningProcesses[pid] = null;\n                    return true;\n                }\n            } catch (e) {\n                console.warn(e);\n            }\n        }\n        return false;\n    }\n    function getLaunchObject(s) {\n        if (typeof s === 'string') {\n            const spl = s.split('@');\n            const name = spl[0];\n            let args = {};\n            if (typeof spl[1] !== 'undefined') {\n                try {\n                    args = JSON.parse(spl[1]);\n                } catch (e) {\n                }\n            }\n            s = {\n                name: name,\n                args: args\n            };\n        }\n        return s;\n    }\n    return class Process {\n        constructor(name, args, metadata) {\n            console.group('Process::constructor()', runningProcesses.length, arguments);\n            this.__pid = runningProcesses.push(this) - 1;\n            this.__pname = name;\n            this.__args = args || {};\n            this.__metadata = metadata || {};\n            this.__started = new Date();\n            this.__destroyed = false;\n            this.__evHandler = new EventHandler(name, [\n                'message',\n                'attention',\n                'hashchange',\n                'api',\n                'destroy',\n                'destroyWindow',\n                'vfs',\n                'vfs:mount',\n                'vfs:unmount',\n                'vfs:mkdir',\n                'vfs:write',\n                'vfs:move',\n                'vfs:copy',\n                'vfs:delete',\n                'vfs:upload',\n                'vfs:update'\n            ]);\n            this.__label = this.__metadata.name;\n            this.__path = this.__metadata.path;\n            this.__scope = this.__metadata.scope || 'system';\n            this.__iter = this.__metadata.className;\n            console.groupEnd();\n        }\n        destroy() {\n            if (!this.__destroyed) {\n                this.__destroyed = true;\n                console.group('Process::destroy()', this.__pid, this.__pname);\n                this._emit('destroy', []);\n                if (this.__evHandler) {\n                    this.__evHandler = this.__evHandler.destroy();\n                }\n                if (this.__pid >= 0) {\n                    runningProcesses[this.__pid] = null;\n                }\n                console.groupEnd();\n                return true;\n            }\n            return false;\n        }\n        _onMessage(msg, obj, opts) {\n            opts = opts || {};\n            let sourceId = opts.source;\n            if (sourceId && typeof sourceId === 'object') {\n                if (sourceId instanceof Process) {\n                    sourceId = sourceId.__pid;\n                } else if (sourceId._app) {\n                    sourceId = sourceId._app ? sourceId._app.__pid : -1;\n                }\n            }\n            if (this.__evHandler && sourceId !== this.__pid) {\n                console.debug('Process::_onMessage()', msg, obj, opts, this.__pid, this.__pname);\n                this.__evHandler.emit('message', [\n                    msg,\n                    obj,\n                    opts\n                ]);\n                if (msg.substr(0, 3) === 'vfs') {\n                    this.__evHandler.emit('vfs', [\n                        msg,\n                        obj,\n                        opts\n                    ]);\n                }\n                this.__evHandler.emit(msg, [\n                    obj,\n                    opts,\n                    msg\n                ]);\n            }\n        }\n        _emit(k, args) {\n            return this.__evHandler ? this.__evHandler.emit(k, args) : null;\n        }\n        _on(k, func) {\n            return this.__evHandler ? this.__evHandler.on(k, func, this) : null;\n        }\n        _off(k, idx) {\n            if (this.__evHandler) {\n                this.__evHandler.off(k, idx);\n            }\n        }\n        _api(method, args, options) {\n            if (typeof options === 'boolean') {\n                options = { indicator: options };\n            } else if (typeof options !== 'object') {\n                options = {};\n            }\n            this._emit('api', [method]);\n            return new Promise((resolve, reject) => {\n                Connection.request('application', {\n                    application: this.__iter,\n                    path: this.__path,\n                    method: method,\n                    args: args\n                }, options).then(res => {\n                    if (!this.__destroyed) {\n                        resolve(res);\n                        return true;\n                    }\n                    console.warn('Process::_api()', 'INGORED RESPONSE: Process was closed');\n                    return false;\n                }).catch(err => {\n                    if (!this.__destroyed) {\n                        reject(err instanceof Error ? err : new Error(err));\n                    }\n                });\n            });\n        }\n        _getArgument(k) {\n            return typeof this.__args[k] === 'undefined' ? null : this.__args[k];\n        }\n        _getArguments() {\n            return this.__args;\n        }\n        _getResource(src, vfspath) {\n            return PackageManager.getPackageResource(this, src, vfspath);\n        }\n        _setArgument(k, v) {\n            this.__args[k] = v;\n        }\n        static kill(pid) {\n            return _kill(pid);\n        }\n        static killAll(match) {\n            let matcher = () => true;\n            if (match) {\n                matcher = match instanceof RegExp ? p => p.__pname.match(match) : p => p.__pname === match;\n            }\n            this.getProcesses().filter(p => matcher(p)).forEach(p => _kill(p.__pid, true));\n            runningProcesses = [];\n        }\n        static message(msg, obj, opts) {\n            opts = opts || {};\n            console.debug('Process::message()', msg, obj, opts);\n            let filter = opts.filter || (() => true);\n            if (typeof filter === 'string') {\n                const s = filter;\n                filter = p => {\n                    return p.__pname === s;\n                };\n            }\n            this.getProcesses().filter(filter).forEach(p => p._onMessage(msg, obj, opts));\n        }\n        static getProcess(name, first) {\n            if (typeof name === 'number') {\n                return runningProcesses[name];\n            }\n            const found = this.getProcesses().filter(p => {\n                return p.__pname === name;\n            });\n            return first ? found[0] : found;\n        }\n        static getProcesses() {\n            return runningProcesses.filter(p => !!p);\n        }\n        static reload(n) {\n            if (!(n instanceof Array)) {\n                n = [n];\n            }\n            n.map(name => this.getProcess(name, true)).filter(p => !!p).forEach(p => {\n                let promise = null;\n                let data = p._getSessionData();\n                let args = {};\n                let name;\n                try {\n                    name = p.__pname;\n                    promise = p.destroy();\n                } catch (e) {\n                    console.warn('Process::reload()', e.stack, e);\n                }\n                if (data !== null) {\n                    args = data.args;\n                    args.__resume__ = true;\n                    args.__windows__ = data.windows || [];\n                }\n                args.__preload__ = { force: true };\n                if (!(promise instanceof Promise)) {\n                    promise = Promise.resolve(true);\n                }\n                if (name) {\n                    promise.then(() => {\n                        return setTimeout(() => {\n                            this.create(name, args);\n                        }, 500);\n                    });\n                }\n            });\n        }\n        static create(name, args, onconstruct) {\n            args = args || {};\n            onconstruct = onconstruct || function () {\n            };\n            const hash = name + JSON.stringify(args);\n            if (alreadyLaunching.indexOf(hash) !== -1) {\n                return Promise.resolve(null);\n            }\n            alreadyLaunching.push(hash);\n            const init = () => {\n                if (!name) {\n                    throw new Error('Cannot Process::create() witout a application name');\n                }\n                const compability = Compability.getCompability();\n                const metadata = PackageManager.getPackage(name);\n                const alreadyRunning = Process.getProcess(name, true);\n                if (!metadata) {\n                    throw new Error(locales._('ERR_APP_LAUNCH_MANIFEST_FAILED_FMT', name));\n                }\n                const compabilityFailures = (metadata.compability || []).filter(c => {\n                    if (typeof compability[c] !== 'undefined') {\n                        return !compability[c];\n                    }\n                    return false;\n                });\n                if (compabilityFailures.length) {\n                    throw new Error(locales._('ERR_APP_LAUNCH_COMPABILITY_FAILED_FMT', name, compabilityFailures.join(', ')));\n                }\n                if (metadata.singular === true && alreadyRunning) {\n                    console.warn('Process::create()', 'detected that this application is a singular and already running...');\n                    alreadyRunning._onMessage('attention', args);\n                    return Promise.resolve(alreadyRunning);\n                }\n                hooks.triggerHook('processStart', [\n                    name,\n                    args\n                ]);\n                Loader.create('Main.launch.' + name, {\n                    title: locales._('LBL_STARTING') + ' ' + metadata.name,\n                    icon: Theme.getIcon(metadata.icon, '16x16')\n                });\n                let pargs = { max: metadata.preloadParallel === true ? Config.getConfig('Connection.PreloadParallel') : metadata.preloadParallel };\n                if (args.__preload__) {\n                    pargs = Object.assign(pargs, args.__preload__);\n                    delete args.__preload__;\n                }\n                return new Promise((resolve, reject) => {\n                    const onerror = e => {\n                        console.warn(e);\n                        return reject(new Error(e));\n                    };\n                    Preloader.preload(metadata.preload, pargs).then(result => {\n                        if (result.failed.length) {\n                            return onerror(locales._('ERR_APP_PRELOAD_FAILED_FMT', name, result.failed.join(',')));\n                        }\n                        if (typeof OSjs.Applications[name] === 'undefined') {\n                            return onerror(new Error(locales._('ERR_APP_RESOURCES_MISSING_FMT', name)));\n                        }\n                        let instance;\n                        try {\n                            const ResolvedPackage = OSjs.Applications[name];\n                            instance = new ResolvedPackage(args, metadata);\n                            onconstruct(instance, metadata);\n                        } catch (e) {\n                            return onerror(e);\n                        }\n                        try {\n                            const settings = SettingsManager.get(instance.__pname) || {};\n                            instance.init(settings, metadata);\n                            hooks.triggerHook('processStarted', [{\n                                    application: instance,\n                                    name: name,\n                                    args: args,\n                                    settings: settings,\n                                    metadata: metadata\n                                }]);\n                        } catch (e) {\n                            return onerror(e);\n                        }\n                        return resolve(instance);\n                    }).catch(onerror);\n                });\n            };\n            const onerror = err => {\n                OSjs.error(locales._('ERR_APP_LAUNCH_FAILED'), locales._('ERR_APP_LAUNCH_FAILED_FMT', name), err, err, true);\n            };\n            return new Promise((resolve, reject) => {\n                console.group('Process::create()', name, args);\n                const remove = () => {\n                    console.groupEnd();\n                    const i = alreadyLaunching.indexOf(hash);\n                    if (i >= 0) {\n                        alreadyLaunching.splice(i, 1);\n                    }\n                    Loader.destroy('Main.launch.' + name);\n                };\n                const fail = e => {\n                    Loader.destroy('Main.launch.' + name);\n                    remove();\n                    onerror(e);\n                    return reject(e);\n                };\n                try {\n                    init().then(resolve).catch(fail).finally(remove);\n                } catch (e) {\n                    fail(e);\n                }\n            });\n        }\n        static createFromArray(list, onconstruct) {\n            list = list || [];\n            onconstruct = onconstruct || function () {\n            };\n            console.info('Process::createFromArray()', list);\n            return Promise.each(list, s => {\n                return new Promise((resolve, reject) => {\n                    s = getLaunchObject(s);\n                    if (s.name) {\n                        try {\n                            this.create(s.name, s.args, (instance, metadata) => {\n                                onconstruct(instance, metadata, s.name, s.args);\n                            }).then(resolve).catch(reject);\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        resolve();\n                    }\n                });\n            });\n        }\n        static createFromFile(file, args) {\n            file = new FileMetadata(file);\n            args = Object.assign({ file: file }, args || {});\n            if (args.args) {\n                Object.keys(args.args).forEach(i => {\n                    args[i] = args.args[i];\n                });\n            }\n            if (!file.path) {\n                throw new Error('Cannot open file without a path');\n            }\n            console.info('Process::createFromFile()', file, args);\n            if (file.mime === 'osjs/application') {\n                return this.create(FS.filename(file.path));\n            } else if (file.type === 'dir') {\n                const fm = SettingsManager.instance('DefaultApplication').get('dir', 'ApplicationFileManager');\n                return this.create(fm, { path: file.path });\n            }\n            return new Promise((resolve, reject) => {\n                const val = SettingsManager.get('DefaultApplication', file.mime);\n                let pack = PackageManager.getPackagesByMime(file.mime);\n                if (!args.forceList && val) {\n                    if (PackageManager.getPackage(val)) {\n                        console.debug('Process::createFromFile()', 'default application', val);\n                        pack = [val];\n                    }\n                }\n                if (pack.length === 0) {\n                    OSjs.error(locales._('ERR_FILE_OPEN'), locales._('ERR_FILE_OPEN_FMT', file.path), locales._('ERR_APP_MIME_NOT_FOUND_FMT', file.mime));\n                    reject(new Error(locales._('ERR_APP_MIME_NOT_FOUND_FMT', file.mime)));\n                } else if (pack.length === 1) {\n                    this.create(pack[0], args).then(resolve).catch(reject);\n                } else {\n                    const DialogWindow = OSjs.require('core/dialog');\n                    DialogWindow.default.create('ApplicationChooser', {\n                        file: file,\n                        list: pack\n                    }, (ev, btn, result) => {\n                        if (btn === 'ok') {\n                            this.create(result.name, args);\n                            SettingsManager.set('DefaultApplication', file.mime, result.useDefault ? result.name : null, true).then(resolve).catch(err => {\n                                reject(typeof err === 'string' ? new Error(err) : err);\n                            });\n                        }\n                    });\n                }\n            });\n        }\n    };\n});"]}